import logging
import asyncio
import fastf1
import json
import os
import feedparser
import aiohttp
from googletrans import Translator
from aiogram import Bot, Dispatcher, Router, types
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.filters.command import Command
from aiogram.types import FSInputFile, InputMediaPhoto
from datetime import datetime, timedelta,date
from aiogram.exceptions import TelegramBadRequest


def find_image(filename):
    for root, dirs, files in os.walk('.'):
        if filename in files:
            return os.path.join(root, filename)
    return None


TOKEN = "7509468581:AAFEBq-zWoYOcZoG5cUfi28DXPrEOFxSuig"

bot = Bot(token=TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
router = Router()
dp.include_router(router)

user_data = {}

cache_dir = '/opt/render/project/src/F1Pulse'
if not os.path.exists(cache_dir):
    os.makedirs(cache_dir)

fastf1.Cache.enable_cache(cache_dir)

logging.basicConfig(level=logging.INFO)



async def send_main_menu(chat_id, language):
    buttons = [
        [
            InlineKeyboardButton(text="üèÅ –ì—Ä–∞–Ω-–ø—Ä–∏" if language == "ru" else "üèÅ Grand Prix", callback_data="grand_prix"),
            InlineKeyboardButton(text="üèÜ –ß–µ–º–ø–∏–æ–Ω–∞—Ç" if language == "ru" else "üèÜ Championship", callback_data="championship")
        ],
        [
            InlineKeyboardButton(text="üõ†Ô∏è –ü–∞–¥–¥–æ–∫" if language == "ru" else "üõ†Ô∏è Paddock", callback_data="paddock"),
            InlineKeyboardButton(text="üì∞ –ù–æ–≤–æ—Å—Ç–∏" if language == "ru" else "üì∞ News", callback_data="f1_news")
        ],
        [InlineKeyboardButton(text="üîÆ –ü—Ä–æ–≥–Ω–æ–∑—ã" if language == "ru" else "üîÆ Predictions", callback_data="predictions")],
        [InlineKeyboardButton(text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏" if language == "ru" else "‚öôÔ∏è Settings", callback_data="settings")]
    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)

    # Find and load the image
    image_path = find_image("main_menu.jpg")
    if image_path:
        photo = FSInputFile(image_path)
        await bot.send_photo(
            chat_id,
            photo=photo,
            reply_markup=keyboard
        )
    else:
        # Fallback to text-only message if image is not found
        await bot.send_message(
            chat_id,
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é F1" if language == "ru" else "F1 Main Menu",
            reply_markup=keyboard
        )



@router.message(Command("start"))
async def start(message: types.Message):
    user_id = message.from_user.id

    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–æ–≤—ã–π, —Å–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å —Å —è–∑—ã–∫–æ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    if user_id not in user_data:
        user_data[user_id] = {"language": "en"}  # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —è–∑—ã–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
        await send_language_selection(message.chat.id)  # –ü–æ–∫–∞–∑–∞—Ç—å –≤—ã–±–æ—Ä —è–∑—ã–∫–∞
    else:
        # –ï—Å–ª–∏ —è–∑—ã–∫ —É–∂–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω, –æ—Ç–∫—Ä—ã–≤–∞–µ–º –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
        language = user_data[user_id]["language"]
        await send_main_menu(message.chat.id, language)

async def send_language_selection(chat_id):
    buttons = [
        [InlineKeyboardButton(text="English", callback_data="set_lang_en")],
        [InlineKeyboardButton(text="–†—É—Å—Å–∫–∏–π", callback_data="set_lang_ru")]
    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    await bot.send_message(chat_id, "Please select your language", reply_markup=keyboard)


@router.callback_query(lambda c: c.data.startswith("set_lang_"))
async def set_language(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    lang_code = callback.data.split("_")[2]

    # –û–±–Ω–æ–≤–ª—è–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –¥–∞–Ω–Ω—ã—Ö
    user_data[user_id]["language"] = lang_code
    await save_user_data()  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è

    await callback.answer("Language updated!" if lang_code == 'en' else '–Ø–∑—ã–∫ –æ–±–Ω–æ–≤–ª–µ–Ω!')
    await callback.message.delete()
    await send_main_menu(callback.message.chat.id, lang_code)


# –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
DATA_FILE = 'user_data.json'

# –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞
def load_user_data():
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, 'r', encoding='utf-8') as file:
                data = json.load(file)
                # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –∫–ª—é—á–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞
                return {int(k): v for k, v in data.items()}
        except Exception as e:
            print(f"Error loading user data: {e}")
            return {}
    return {}

# –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
async def save_user_data():
    try:
        with open(DATA_FILE, 'w', encoding='utf-8') as file:
            json.dump(user_data, file, ensure_ascii=False, indent=4)
    except Exception as e:
        print(f"Error saving user data: {e}")

async def send_text_menu(callback, language, keyboard):
    text = "\u200B"  # –ù–µ–≤–∏–¥–∏–º—ã–π —Å–∏–º–≤–æ–ª
    try:
        await callback.message.edit_text(text, reply_markup=keyboard)
    except TelegramBadRequest as e:
        if "message is not modified" in str(e).lower():
            pass
        else:
            await callback.message.delete()
            await callback.message.answer(text, reply_markup=keyboard)


async def fetch_championship_data(year, championship_type):
    base_url = "http://api.jolpi.ca/ergast/f1"
    endpoint = "driverstandings" if championship_type == "drivers" else "constructorstandings"
    url = f"{base_url}/{year}/{endpoint}"

    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            if response.status == 200:
                return await response.json()
            else:
                return None


@router.callback_query(lambda c: c.data == "championship")
async def show_championship_archive(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    buttons = [
        [InlineKeyboardButton(text="2009-2013", callback_data="seasons_2009_2013")],
        [InlineKeyboardButton(text="2014-2017", callback_data="seasons_2014_2017")],
        [InlineKeyboardButton(text="2018-2022", callback_data="seasons_2018_2022")],
        [InlineKeyboardButton(text="2023-2025", callback_data="seasons_2023_2025")],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="main_menu")]
    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    text = "–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥:" if language == "ru" else "Select a period:"

    try:
        await callback.message.edit_text(text, reply_markup=keyboard)
    except TelegramBadRequest as e:
        if "there is no text in the message to edit" in str(e):
            await callback.message.delete()
            await callback.message.answer(text, reply_markup=keyboard)
        else:
            await callback.message.answer(text, reply_markup=keyboard)



@router.callback_query(lambda c: c.data.startswith("championship_"))
async def show_championship_type(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    year = callback.data.split("_")[1]
    buttons = [
        [
            InlineKeyboardButton(
                text="üèÜ –õ–∏—á–Ω—ã–π –∑–∞—á–µ—Ç" if language == "ru" else "üèÜ Drivers' Championship",
                callback_data=f"drivers_championship_{year}"
            )
        ],
        [
            InlineKeyboardButton(
                text="üèÜ –ö—É–±–æ–∫ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤" if language == "ru" else "üèÜ Constructors' Championship",
                callback_data=f"constructors_championship_{year}"
            )
        ],
        [
            InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="championship")
        ]
    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    await callback.message.edit_text(
        f"–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —á–µ–º–ø–∏–æ–Ω–∞—Ç–∞ –¥–ª—è {year} –≥–æ–¥–∞:" if language == "ru" else f"Select championship type for {year}:",
        reply_markup=keyboard
    )


@router.callback_query(lambda c: c.data.startswith("seasons_"))
async def show_seasons(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    _, start_year, end_year = callback.data.split("_")
    seasons = range(int(start_year), int(end_year) + 1)
    buttons = [
        [InlineKeyboardButton(text=f"{year}", callback_data=f"championship_{year}")]
        for year in seasons
    ]
    buttons.append([InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="championship")])
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    text = "üìÖ –í—ã–±–µ—Ä–∏—Ç–µ —Å–µ–∑–æ–Ω:" if language == "ru" else "üìÖ Select a season:"
    await callback.message.edit_text(text, reply_markup=keyboard)


@router.callback_query(lambda c: c.data.startswith("drivers_championship_"))
async def show_drivers_championship(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    year = callback.data.split("_")[2]
    await callback.message.edit_text("–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤..." if language == "ru" else "Loading results...")

    data = await fetch_championship_data(year, "drivers")
    if data and "MRData" in data and "StandingsTable" in data["MRData"]:
        standings = data["MRData"]["StandingsTable"]["StandingsLists"]
        if standings and standings[0]["DriverStandings"]:
            standings = standings[0]["DriverStandings"]
            text = f"üèÜ {'–õ–∏—á–Ω—ã–π –∑–∞—á–µ—Ç' if language == 'ru' else 'Drivers Championship'} {year}:\n\n"
            for driver in standings:
                position = driver.get('position', 'N/A')  # –ò—Å–ø–æ–ª—å–∑—É–µ–º get –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
                name = f"{driver['Driver']['givenName']} {driver['Driver']['familyName']}"
                nationality = driver['Driver']['nationality']
                points = driver['points']
                flag = get_flag_emoji(nationality)
                text += f"{position}. {flag}{name} ({points})\n"
        else:
            text = "–î–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã" if language == "ru" else "Data unavailable"
    else:
        text = "–î–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã" if language == "ru" else "Data unavailable"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data=f"championship_{year}")]
    ])
    await callback.message.edit_text(text, reply_markup=keyboard)


@router.callback_query(lambda c: c.data.startswith("constructors_championship_"))
async def show_constructors_championship(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    year = callback.data.split("_")[2]
    await callback.message.edit_text("–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤..." if language == "ru" else "Loading results...")

    data = await fetch_championship_data(year, "constructors")
    if data and "MRData" in data and "StandingsTable" in data["MRData"]:
        standings = data["MRData"]["StandingsTable"]["StandingsLists"]
        if standings and standings[0]["ConstructorStandings"]:
            standings = standings[0]["ConstructorStandings"]
            text = f"üèÜ {'–ö—É–±–æ–∫ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤' if language == 'ru' else 'Constructors Championship'} {year}:\n\n"
            for constructor in standings:
                position = constructor.get('position', 'N/A')  # –ò—Å–ø–æ–ª—å–∑—É–µ–º get –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
                name = constructor['Constructor']['name']
                nationality = constructor['Constructor']['nationality']
                points = constructor['points']
                flag = get_flag_emoji(nationality)
                text += f"{position}. {flag}{name} ({points})\n"
        else:
            text = "–î–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã" if language == "ru" else "Data unavailable"
    else:
        text = "–î–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã" if language == "ru" else "Data unavailable"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data=f"championship_{year}")]
    ])
    await callback.message.edit_text(text, reply_markup=keyboard)


def get_flag_emoji(nationality):
    # –°–ª–æ–≤–∞—Ä—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –Ω–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–µ–π –∏ —Ñ–ª–∞–≥–æ–≤
    flags = {
        "Dutch": "üá≥üá±", "British": "üá¨üáß", "Monegasque": "üá≤üá®", "Australian": "üá¶üá∫",
        "Spanish": "üá™üá∏", "Mexican": "üá≤üáΩ", "French": "üá´üá∑", "German": "üá©üá™",
        "Japanese": "üáØüáµ", "Canadian": "üá®üá¶", "Danish": "üá©üá∞", "Thai": "üáπüá≠",
        "Chinese": "üá®üá≥", "Finnish": "üá´üáÆ", "American": "üá∫üá∏", "Italian": "üáÆüáπ",
        "Austrian": "üá¶üáπ", "Swiss": "üá®üá≠", "New Zealander": 'üá≥üáø', "Polish": "üáµüá±",
        "Russian": "üá∑üá∫", "Brazilian": "üáßüá∑", "Belgian": "üáßüá™", "Swedish": "üá∏üá™",
        "Venezuelan": "üáªüá™", "Indian": "üáÆüá≥", "Malaysian": "üá≤üáæ", "Indonesian": "üáÆüá©",

    }
    return flags.get(nationality, "")


async def fetch_weather_data():
    url = "https://api.openf1.org/v1/weather"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            if response.status == 200:
                data = await response.json()
                logging.info(f"Weather data fetched: {data}")
                return data
            else:
                logging.error(f"Failed to fetch weather data: {response.status}")
                return None


@router.callback_query(lambda c: c.data == "weather")
async def show_weather(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]

    try:
        await callback.message.delete()
        loading_message = await bot.send_message(callback.message.chat.id,
                                                 "–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤..." if language == "ru" else "Loading results...")

        weather_data = await fetch_weather_data()

        if weather_data:
            text = format_weather_data(weather_data, language)
        else:
            text = "–î–∞–Ω–Ω—ã–µ –æ –ø–æ–≥–æ–¥–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã" if language == "ru" else "Weather data unavailable"
    except Exception as e:
        logging.error(f"Error fetching weather data: {e}")
        text = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–≥–æ–¥–µ" if language == "ru" else "Error fetching weather data"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="grand_prix")]
    ])

    try:
        await loading_message.edit_text(text, reply_markup=keyboard)
    except TelegramBadRequest as e:
        if "message is not modified" in str(e).lower():
            pass
        else:
            await loading_message.delete()
            await bot.send_message(callback.message.chat.id, text, reply_markup=keyboard)


def format_weather_data(weather_data, language):
    if not weather_data or not isinstance(weather_data, list) or len(weather_data) == 0:
        return "–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–≥–æ–¥–µ." if language == "ru" else "Weather data format error."

    latest_weather = weather_data[-1]

    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–∞—Å—Å–µ
    meeting_key = latest_weather.get('meeting_key', 'N/A')

    # –ó–¥–µ—Å—å –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è meeting_key —Å –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏ —Ç—Ä–∞—Å—Å
    track_names = {
        1252: {"ru": "–Ø—Å –ú–∞—Ä–∏–Ω–∞", "en": "Yas Marina"},
        # –î–æ–±–∞–≤—å—Ç–µ –¥—Ä—É–≥–∏–µ —Ç—Ä–∞—Å—Å—ã –ø–æ –º–µ—Ä–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
    }

    track_name = track_names.get(meeting_key, {}).get(language, "Unknown Track")

    air_temp = latest_weather.get('air_temperature', 'N/A')
    humidity = latest_weather.get('humidity', 'N/A')
    rainfall = latest_weather.get('rainfall', 'N/A')
    wind_speed = latest_weather.get('wind_speed', 'N/A')
    track_temp = latest_weather.get('track_temperature', 'N/A')
    pressure = latest_weather.get('pressure', 'N/A')
    wind_direction = latest_weather.get('wind_direction', 'N/A')

    if language == "ru":
        return (f"üå§Ô∏è –ü–æ–≥–æ–¥–∞ –Ω–∞ —Ç—Ä–∞—Å—Å–µ {track_name}:\n\n"
                f"üå°Ô∏è –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –≤–æ–∑–¥—É—Ö–∞: {air_temp}¬∞C\n"
                f"üõ£Ô∏è –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ —Ç—Ä–∞—Å—Å—ã: {track_temp}¬∞C\n"
                f"üíß –í–ª–∞–∂–Ω–æ—Å—Ç—å: {humidity}%\n"
                f"üåßÔ∏è –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –æ—Å–∞–¥–∫–æ–≤: {rainfall}%\n"
                f"üí® –°–∫–æ—Ä–æ—Å—Ç—å –≤–µ—Ç—Ä–∞: {wind_speed} –∫–º/—á\n"
                f"üß≠ –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ç—Ä–∞: {wind_direction}¬∞\n"
                f"üî¨ –î–∞–≤–ª–µ–Ω–∏–µ: {pressure} –≥–ü–∞")
    else:
        return (f"üå§Ô∏è Weather at {track_name} track:\n\n"
                f"üå°Ô∏è Air temperature: {air_temp}¬∞C\n"
                f"üõ£Ô∏è Track temperature: {track_temp}¬∞C\n"
                f"üíß Humidity: {humidity}%\n"
                f"üåßÔ∏è Rainfall probability: {rainfall}%\n"
                f"üí® Wind speed: {wind_speed} km/h\n"
                f"üß≠ Wind direction: {wind_direction}¬∞\n"
                f"üî¨ Pressure: {pressure} hPa")



@router.callback_query(lambda c: c.data == "grand_prix")
async def show_grand_prix_menu(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    buttons = [
    [
        InlineKeyboardButton(text="üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ" if language == "ru" else "üìÖ Schedule", callback_data="schedule"),
        InlineKeyboardButton(text="üèÅ –ù–µ–¥–∞–≤–Ω–∏–π GP" if language == "ru" else "üèÅ Last GP",callback_data="last_results"),
    ],
    [
        InlineKeyboardButton(text="üå§Ô∏è –ü–æ–≥–æ–¥–∞" if language == "ru" else "üå§Ô∏è Weather", callback_data="weather"),
        InlineKeyboardButton(text="üìö –ê—Ä—Ö–∏–≤" if language == "ru" else "üìö Archive", callback_data="archive"),
    ],
    [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="main_menu")]

    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    image_path = find_image("grand_prix.jpg")
    if image_path:
        photo = FSInputFile(image_path)
        try:
            # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            await callback.message.edit_media(
                media=InputMediaPhoto(media=photo),
                reply_markup=keyboard
            )
        except TelegramBadRequest as e:
            if "there is no media in the message to edit" in str(e).lower():
                # –ï—Å–ª–∏ –Ω–µ—Ç –º–µ–¥–∏–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
                await callback.message.delete()
                await bot.send_photo(
                    chat_id=callback.message.chat.id,
                    photo=photo,
                    reply_markup=keyboard
                )
            else:
                # –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞, –ø—Ä–æ–±—É–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
                await callback.message.edit_text( reply_markup=keyboard)
    else:
        # –ï—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
        try:
            await callback.message.edit_text( reply_markup=keyboard)
        except TelegramBadRequest as e:
            if "message is not modified" in str(e).lower():
                pass
            else:
                # –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                await callback.message.delete()
                await callback.message.answer( reply_markup=keyboard)



@router.callback_query(lambda c: c.data.startswith("set_lang_"))
async def set_language(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    lang_code = callback.data.split("_")[2]
    user_data[user_id]["language"] = lang_code
    await callback.answer("Language updated!" if lang_code == 'en' else '–Ø–∑—ã–∫ –æ–±–Ω–æ–≤–ª–µ–Ω!')
    await callback.message.delete()
    await send_main_menu(callback.message.chat.id, lang_code)


@router.callback_query(lambda c: c.data == "archive")
async def show_archive_seasons(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    seasons = [2021, 2023, 2024, 2025]
    buttons = [
        [InlineKeyboardButton(text=f"–°–µ–∑–æ–Ω {year}" if language == "ru" else f"Season {year}",
                              callback_data=f"season_{year}")]
        for year in seasons
    ]
    buttons.append([InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="grand_prix")])
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    text = "–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ–∑–æ–Ω:" if language == "ru" else "Select a season:"

    try:
        await callback.message.edit_text(text, reply_markup=keyboard)
    except TelegramBadRequest as e:
        if "message is not modified" in str(e).lower():
            pass
        elif "message to edit not found" in str(e).lower() or "there is no text in the message to edit" in str(
                e).lower():
            await callback.message.delete()
            await callback.message.answer(text, reply_markup=keyboard)
        else:
            raise


@router.callback_query(lambda c: c.data.startswith("season_"))
async def show_season_races(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    year = int(callback.data.split("_")[1])
    await callback.message.edit_text(
        "–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤..." if language == "ru" else "Loading results..."
    )
    try:
        if year == 2025:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è 2025 –≥–æ–¥–∞
            current_year = datetime.now().year
            if current_year < 2025:
                raise Exception("Data for 2025 is not available yet")

        schedule = fastf1.get_event_schedule(year)
        # –§–∏–ª—å—Ç—Ä—É–µ–º –≥–æ–Ω–∫–∏, –∏—Å–∫–ª—é—á–∞—è –ø—Ä–µ–¥—Å–µ–∑–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã
        race_schedule = schedule[schedule['EventFormat'] == 'conventional']

        buttons = [
            [InlineKeyboardButton(text=f"{race['RoundNumber']}. {race['EventName']}",
                                  callback_data=f"race_{year}_{race['RoundNumber']}")]
            for _, race in race_schedule.iterrows()
        ]
        buttons.append(
            [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="archive")]
        )
        keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)

        await callback.message.edit_text(
            f"–ì–æ–Ω–∫–∏ —Å–µ–∑–æ–Ω–∞ {year}:" if language == "ru" else f"Races of {year} season:",
            reply_markup=keyboard
        )
    except Exception as e:
        print(f"Error loading season data: {e}")
        error_message = "–î–∞–Ω–Ω—ã–µ –æ —Å–µ–∑–æ–Ω–µ 2025 –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã." if year == 2025 else "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö —Å–µ–∑–æ–Ω–∞."
        error_message = error_message if language == "ru" else "Data for 2025 season is not available yet." if year == 2025 else "Error loading season data."
        await callback.message.edit_text(
            error_message,
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="archive")]
            ])
        )


@router.callback_query(lambda c: c.data.startswith("race_"))
async def show_race_details(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    _, year, round_number = callback.data.split("_")
    year = int(year)
    round_number = int(round_number)

    await callback.message.edit_text(
        "–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤..." if language == "ru" else "Loading results..."
    )

    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å –ø–æ–º–æ—â—å—é FastF1
        session = fastf1.get_session(year, round_number, 'R')
        session.load()

        # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –≥–æ–Ω–∫–µ
        results = session.results
        podium = results.iloc[:3][['DriverNumber', 'FullName', 'TeamName']]
        fastest_lap = session.laps.pick_fastest()

        race_info = f"üèéÔ∏è {session.event['EventName']} {year}\n"
        race_info += f"üìÖ {session.date.strftime('%d.%m.%Y')}\n\n"
        race_info += "–ü–æ–¥–∏—É–º:\n" if language == "ru" else "Podium:\n"
        for i, (_, driver) in enumerate(podium.iterrows(), 1):
            race_info += f"{i}. {driver['FullName']} ({driver['TeamName']})\n"

        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±—ã—Å—Ç—Ä–æ–º –∫—Ä—É–≥–µ
        fastest_lap_time = fastest_lap['LapTime'].total_seconds()
        minutes = int(fastest_lap_time // 60)
        seconds = int(fastest_lap_time % 60)
        milliseconds = int((fastest_lap_time % 1) * 1000)
        race_info += (
            f"\n‚è± {'–ë—ã—Å—Ç—Ä—ã–π –∫—Ä—É–≥' if language == 'ru' else 'Fastest lap'}: {fastest_lap['Driver']} "
            f"- {minutes:02d}:{seconds:02d}.{milliseconds:03d}"
        )

        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ –≤–∏–¥–µ–æ
        race_name_slug = session.event['EventName'].replace(" ", "_").lower()
        youtube_url = f"https://www.youtube.com/results?search_query={year}_{race_name_slug}_highlights"

        # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π YouTube
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(
                text="‚ñ∂Ô∏è –û—Å–Ω–æ–≤–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã –≥–æ–Ω–∫–∏" if language == 'ru' else "‚ñ∂Ô∏è Race highlights",
                url=youtube_url
            )],
            [InlineKeyboardButton(
                text="üîô –ù–∞–∑–∞–¥" if language == 'ru' else "üîô Back",
                callback_data=f"season_{year}"
            )]
        ])

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        await callback.message.edit_text(
            race_info,
            reply_markup=keyboard
        )

    except Exception as e:
        print(f"Error loading race data: {e}")
        await callback.message.edit_text(
            "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –≥–æ–Ω–∫–∏" if language == "ru" else "Error loading race data",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(
                    text="üîô –ù–∞–∑–∞–¥" if language == 'ru' else "üîô Back",
                    callback_data=f"season_{year}"
                )]
            ])
        )


async def fetch_f1_news(language):
    feed_url = "https://www.racefans.net/feed/"
    feed = await asyncio.to_thread(feedparser.parse, feed_url)

    translator = Translator()
    news_items = []
    for entry in feed.entries[:3]:  # –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ 3 –ø–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
        pub_date = datetime.strptime(entry.published, "%a, %d %b %Y %H:%M:%S +0000")
        title = entry.title if language == 'en' else translator.translate(entry.title, dest='ru').text
        news_items.append({
            "title": title,
            "link": entry.link,
            "published": pub_date,
            "image_url": entry.media_content[0]['url'] if 'media_content' in entry else None
        })

    return news_items


@router.callback_query(lambda c: c.data == "f1_news")
async def show_f1_news(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]

    # –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö
    loading_message = await bot.send_message(callback.message.chat.id,
        "–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö..." if language == "ru" else "Loading data...")

    news = await fetch_f1_news(language)

    # –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä–æ–µ –º–µ–Ω—é
    await callback.message.delete()

    sent_messages = []
    for item in news[:3]:  # –ü–æ–∫–∞–∑–∞—Ç—å —Ç–æ–ª—å–∫–æ 3 –ø–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
        caption = f"üì∞ {item['title']}\n\nüìÖ {item['published']}\n\nüîó {item['link']}"

        try:
            if item['image_url']:
                message = await bot.send_photo(
                    chat_id=callback.message.chat.id,
                    photo=item['image_url'],
                    caption=caption,
                    parse_mode='HTML'
                )
            else:
                message = await bot.send_message(
                    chat_id=callback.message.chat.id,
                    text=caption,
                    parse_mode='HTML'
                )
            sent_messages.append(message.message_id)
        except Exception as e:
            print(f"Error sending news: {e}")

    # –£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ
    await loading_message.delete()

    buttons = [[InlineKeyboardButton(text="üîô" if language == "ru" else "üîô",
                                     callback_data=f"delete_news_{','.join(map(str, sent_messages))}")]]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)

    await bot.send_message(
        chat_id=callback.message.chat.id,
        text="–ù–∞–∑–∞–¥:" if language == "ru" else "Back:",
        reply_markup=keyboard
    )




@router.callback_query(lambda c: c.data.startswith("delete_news_"))
async def delete_news_and_return(callback: types.CallbackQuery):
    message_ids = callback.data.split("_")[2].split(",")
    for message_id in message_ids:
        try:
            await bot.delete_message(callback.message.chat.id, int(message_id))
        except Exception as e:
            print(f"Error deleting message {message_id}: {e}")

    await callback.message.delete()
    await send_main_menu(callback.message.chat.id, user_data[callback.from_user.id]["language"])




race_cache = {}
CACHE_EXPIRATION = timedelta(hours=1)


LAST_RACE_FILE = 'last_race.json'

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≥–æ–Ω–∫–µ
def load_last_race():
    if os.path.exists(LAST_RACE_FILE):
        with open(LAST_RACE_FILE, 'r', encoding='utf-8') as file:
            return json.load(file)
    return None

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≥–æ–Ω–∫–µ
def save_last_race(race_data):
    with open(LAST_RACE_FILE, 'w', encoding='utf-8') as file:
        json.dump(race_data, file, ensure_ascii=False, indent=4)


NOTIFICATIONS_FILE = 'notifications.json'

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è—Ö
def load_notifications():
    if os.path.exists(NOTIFICATIONS_FILE):
        with open(NOTIFICATIONS_FILE, 'r', encoding='utf-8') as file:
            return json.load(file)
    return {}

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è—Ö
def save_notifications(notifications):
    with open(NOTIFICATIONS_FILE, 'w', encoding='utf-8') as file:
        json.dump(notifications, file, ensure_ascii=False, indent=4)


@router.callback_query(lambda c: c.data == "last_results")
async def show_last_results(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]

    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ –º–µ–Ω—é
    await callback.message.delete()

    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ
    loading_message = await bot.send_message(callback.message.chat.id,
                                             "–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤..." if language == "ru" else "Loading results...")

    race_data = await get_race_results()

    if race_data and race_data["completed"]:
        formatted_results = format_race_results(race_data, language)
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="grand_prix")]
        ])
        await loading_message.edit_text(formatted_results, reply_markup=keyboard, parse_mode="HTML")
    else:
        error_text = "–ò–∑–≤–∏–Ω–∏—Ç–µ, —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ—Å–ª–µ–¥–Ω–µ–π –≥–æ–Ω–∫–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã." if language == "ru" else "Sorry, the results of the last race are not available."
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="grand_prix")]
        ])
        await loading_message.edit_text(error_text, reply_markup=keyboard)


async def get_race_results():
    try:
        current_year = datetime.now().year
        schedule = fastf1.get_event_schedule(current_year)
        last_race = schedule[schedule['EventDate'] < datetime.now()].iloc[-1]
        session = fastf1.get_session(current_year, last_race['EventName'], 'R')
        await asyncio.to_thread(session.load)
        results = session.results

        fetched_results = {
            "name": last_race['EventName'],
            "date": last_race['EventDate'].strftime("%Y-%m-%d"),
            "completed": True,
            "results": [
                {
                    "position": int(result['Position']) if isinstance(result['Position'], (int, float)) else result[
                        'PositionText'],
                    "driver": result.get('FullName', 'Unknown Driver'),
                    "team": result.get('TeamName', 'Unknown Team'),
                    "points": int(result.get('Points', 0)),
                }
                for _, result in results.iterrows()
            ]
        }
        return fetched_results
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≥–æ–Ω–∫–∏: {e}")
        return None


async def send_favorite_notifications(race_results):
    notifications = load_notifications()  # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    for user_id, data in user_data.items():
        favorite_driver = data.get("favorite_driver")
        favorite_team = data.get("favorite_team")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—ã–±—Ä–∞–Ω—ã –ª–∏ –ª—é–±–∏–º—ã–µ –ø–∏–ª–æ—Ç—ã –∏–ª–∏ –∫–æ–º–∞–Ω–¥—ã
        if not favorite_driver and not favorite_team:
            continue  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –±–µ–∑ –≤—ã–±–æ—Ä–∞

        language = data["language"]

        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ–Ω–∫–∏ –∏ –¥–∞—Ç—É
        race_name = race_results["name"]
        race_date_obj = datetime.strptime(race_results["date"], "%Y-%m-%d")
        race_date = (
            race_date_obj.strftime("%d %B %Y").replace("December", "–î–µ–∫–∞–±—Ä—è") if language == "ru"
            else race_date_obj.strftime("%B %d, %Y")
        )

        # –ó–∞–≥–æ–ª–æ–≤–æ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        header = (
            f"üèéÔ∏è –ù–µ–¥–∞–≤–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ –≥–æ–Ω–∫–µ {race_name}:\n–î–∞—Ç–∞: {race_date}\n\n"
            if language == "ru"
            else f"üèéÔ∏è Recent results in the {race_name}:\nDate: {race_date}\n\n"
        )

        driver_message = ""
        if favorite_driver:
            driver_result = next((r for r in race_results["results"] if r["driver"] == favorite_driver), None)
            if driver_result:
                position = driver_result["position"]
                points = driver_result["points"]
                if position in ["DNF", "DSQ"]:
                    driver_message = (
                        f"üë§ –í–∞—à –ª—é–±–∏–º—ã–π –ø–∏–ª–æ—Ç {favorite_driver} –Ω–µ —Ñ–∏–Ω–∏—à–∏—Ä–æ–≤–∞–ª (—Å—Ç–∞—Ç—É—Å: {position}).\n"
                        if language == "ru"
                        else f"üë§ Your favorite driver {favorite_driver} did not finish (status: {position}).\n"
                    )
                elif points > 0:
                    driver_message = (
                        f"üë§ –í–∞—à –ª—é–±–∏–º—ã–π –ø–∏–ª–æ—Ç {favorite_driver} –∑–∞–Ω—è–ª {position} –º–µ—Å—Ç–æ –∏ –∑–∞—Ä–∞–±–æ—Ç–∞–ª {points} –æ—á–∫–æ–≤.\n"
                        if language == "ru"
                        else f"üë§ Your favorite driver {favorite_driver} finished {position}th and earned {points} points.\n"
                    )
                else:
                    driver_message = (
                        f"üë§ –í–∞—à –ª—é–±–∏–º—ã–π –ø–∏–ª–æ—Ç {favorite_driver} –∑–∞–Ω—è–ª {position} –º–µ—Å—Ç–æ.\n"
                        if language == "ru"
                        else f"üë§ Your favorite driver {favorite_driver} finished {position}th.\n"
                    )

        team_message = ""
        if favorite_team:
            team_results = [r for r in race_results["results"] if r["team"] == favorite_team]
            total_points = sum(r["points"] for r in team_results)
            team_message = (
                f"üèÅ –í–∞—à–∞ –ª—é–±–∏–º–∞—è –∫–æ–º–∞–Ω–¥–∞ {favorite_team} –∑–∞—Ä–∞–±–æ—Ç–∞–ª–∞ {total_points} –æ—á–∫–æ–≤ –≤ —ç—Ç–æ–π –≥–æ–Ω–∫–µ."
                if language == "ru"
                else f"üèÅ Your favorite team {favorite_team} earned {total_points} points in this race."
            )

        full_message = header + driver_message + team_message

        try:
            message = await bot.send_message(user_id, full_message)
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
            notifications[user_id] = {
                'message_id': message.message_id,
                'timestamp': datetime.now().isoformat(),
                'race_name': race_name,
                'race_date': race_results['date']
            }
            save_notifications(notifications)  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è—Ö
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")


async def delete_old_notifications():
    notifications = load_notifications()  # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    current_time = datetime.now()

    for user_id, data in list(notifications.items()):
        timestamp = datetime.fromisoformat(data['timestamp'])

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø—Ä–æ—à–ª–æ –ª–∏ 48 —á–∞—Å–æ–≤ —Å –º–æ–º–µ–Ω—Ç–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏
        if current_time - timestamp > timedelta(hours=48):
            try:
                await bot.delete_message(user_id, data['message_id'])  # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                del notifications[user_id]  # –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å –∏–∑ —Å–ª–æ–≤–∞—Ä—è
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")

    save_notifications(notifications)  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è—Ö


def format_race_results(results, language):
    if not results or not results.get("results"):
        return "–ò–∑–≤–∏–Ω–∏—Ç–µ, —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≥–æ–Ω–∫–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã." if language == "ru" else "Sorry, race results are not available."

    title = "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã" if language == "ru" else "Results"
    date_obj = datetime.strptime(results['date'], "%Y-%m-%d")

    if language == "ru":
        formatted_date = date_obj.strftime("%d %B %Y").replace("December", "–î–µ–∫–∞–±—Ä—è")
    else:
        formatted_date = date_obj.strftime("%B %d %Y")

    header = f"üèéÔ∏è {title}: {results['name']}\nüìÖ {formatted_date}\n\n"




    team_logos = {
        "McLaren": "üü†",
        "Ferrari": "üî¥",
        "Red Bull Racing": "üîµ",
        "Mercedes": "‚ö™Ô∏è",
        "Aston Martin": "üíö",
        "Alpine": "üíô",
        "Haas F1 Team": "‚ö™Ô∏è",
        "RB": "üîµ",
        "Williams": "üîµ",
        "Kick Sauber": "üíö"
    }




    medals = ["ü•á", "ü•à", "ü•â"]
    table = ""
    for i, result in enumerate(results["results"], 1):
        position = medals[i - 1] if i <= 3 else f"{i:2d}."
        driver = result['driver']
        team = result['team']
        team_logo = team_logos.get(team, "")
        points = result['points']

        if i <= 10:
            table += f"{position} <b>{driver}</b>\n{team_logo}{team} | {points} {'–æ—á–∫–æ–≤' if language == 'ru' else 'pts'}\n\n"
        else:
            table += f"{position} <b>{driver}</b>\n{team_logo}{team}\n\n"

    return header + table


@router.callback_query(lambda c: c.data == "paddock")
async def show_technical_menu(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    buttons = [
        [
            InlineKeyboardButton(text="üë• –ü–∏–ª–æ—Ç—ã" if language == "ru" else "üë• Drivers", callback_data="drivers"),
            InlineKeyboardButton(text="üèéÔ∏è –ë–æ–ª–∏–¥—ã" if language == "ru" else "üèéÔ∏è Cars", callback_data="tech_cars")
        ],
        [
            InlineKeyboardButton(text="üîß –î–≤–∏–≥–∞—Ç–µ–ª–∏" if language == "ru" else "üîß Engines", callback_data="tech_engines"),
            InlineKeyboardButton(text="üìè –†–µ–≥–ª–∞–º–µ–Ω—Ç" if language == "ru" else "üìè Regulations", callback_data="tech_regulations")
        ],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="main_menu")]
    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)

    image_path = find_image("paddock.jpg")
    if image_path:
        photo = FSInputFile(image_path)
        try:
            await callback.message.delete()
            await bot.send_photo(
                chat_id=callback.message.chat.id,
                photo=photo,
                reply_markup=keyboard
            )
        except Exception as e:
            print(f"Error sending photo: {e}")
            await callback.message.edit_text(reply_markup=keyboard)
    else:
        await callback.message.edit_text(reply_markup=keyboard)



@router.callback_query(lambda c: c.data == "tech_cars")
async def show_tech_cars(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    language = user_data[user_id]["language"]
    text = ("üèéÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ–ª–∏–¥–∞—Ö –§–æ—Ä–º—É–ª—ã 1:\n\n"
            "‚Ä¢ –®–∞—Å—Å–∏: –ú–æ–Ω–æ–∫–æ–∫ –∏–∑ —É–≥–ª–µ—Ä–æ–¥–Ω–æ–≥–æ –≤–æ–ª–æ–∫–Ω–∞\n"
            "‚Ä¢ –í–µ—Å: –ú–∏–Ω–∏–º—É–º 798 –∫–≥ —Å –ø–∏–ª–æ—Ç–æ–º\n"
            "‚Ä¢ –†–∞–∑–º–µ—Ä—ã: –î–ª–∏–Ω–∞ –¥–æ 5.6 –º, —à–∏—Ä–∏–Ω–∞ –¥–æ 2 –º\n"
            "‚Ä¢ –ê—ç—Ä–æ–¥–∏–Ω–∞–º–∏–∫–∞: –ü–µ—Ä–µ–¥–Ω–µ–µ –∏ –∑–∞–¥–Ω–µ–µ –∞–Ω—Ç–∏–∫—Ä—ã–ª–æ, –¥–Ω–∏—â–µ —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º –∑–µ–º–ª–∏") if language == "ru" else \
        ("üèéÔ∏è Formula 1 Car Information:\n\n"
         "‚Ä¢ Chassis: Carbon fiber monocoque\n"
         "‚Ä¢ Weight: Minimum 798 kg including driver\n"
         "‚Ä¢ Dimensions: Up to 5.6 m long, 2 m wide\n"
         "‚Ä¢ Aerodynamics: Front and rear wings, ground effect floor")


    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="paddock")]
    ])

    image_path = find_image("car.jpg")
    if image_path:
        photo = FSInputFile(image_path)
        await callback.message.delete()
        await bot.send_photo(
            chat_id=callback.message.chat.id,
            photo=photo,
            caption=text,
            reply_markup=keyboard
        )
    else:
        await callback.message.edit_text(text, reply_markup=keyboard)



@router.callback_query(lambda c: c.data == "tech_engines")
async def show_tech_engines(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    language = user_data[user_id]["language"]
    text = ("üîß –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–≤–∏–≥–∞—Ç–µ–ª—è—Ö –§–æ—Ä–º—É–ª—ã 1:\n\n"
            "‚Ä¢ –¢–∏–ø: 1.6 –ª V6 —Ç—É—Ä–±–æ-–≥–∏–±—Ä–∏–¥\n"
            "‚Ä¢ –ú–æ—â–Ω–æ—Å—Ç—å: –û–∫–æ–ª–æ 1000 –ª.—Å.\n"
            "‚Ä¢ –û–±–æ—Ä–æ—Ç—ã: –î–æ 15,000 –æ–±/–º–∏–Ω\n"
            "‚Ä¢ –ì–∏–±—Ä–∏–¥–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞: MGU-K –∏ MGU-H") if language == "ru" else \
        ("üîß Formula 1 Engine Information:\n\n"
         "‚Ä¢ Type: 1.6L V6 turbo-hybrid\n"
         "‚Ä¢ Power: Around 1000 hp\n"
         "‚Ä¢ RPM: Up to 15,000 rpm\n"
         "‚Ä¢ Hybrid system: MGU-K and MGU-H")

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="paddock")]
    ])
    image_path = find_image("f1_engine.jpg")
    if image_path:
        photo = FSInputFile(image_path)
        await callback.message.delete()
        await bot.send_photo(
            chat_id=callback.message.chat.id,
            photo=photo,
            caption=text,
            reply_markup=keyboard
        )
    else:
        await callback.message.edit_text(text, reply_markup=keyboard)

@router.callback_query(lambda c: c.data == "tech_regulations")
async def show_tech_regulations(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    language = user_data[user_id]["language"]
    text = ("üìè –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π —Ä–µ–≥–ª–∞–º–µ–Ω—Ç –§–æ—Ä–º—É–ª—ã 1 2025:\n\n"
            "‚Ä¢ –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –±—é–¥–∂–µ—Ç–∞: $135 –º–ª–Ω –Ω–∞ —Å–µ–∑–æ–Ω\n"
            "‚Ä¢ –ê—ç—Ä–æ–¥–∏–Ω–∞–º–∏–∫–∞: –ù–æ–≤—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ —Ç–µ—Å—Ç–∞–º –≤ –∞—ç—Ä–æ–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π —Ç—Ä—É–±–µ\n"
            "‚Ä¢ –î–≤–∏–≥–∞—Ç–µ–ª–∏: –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –¥–æ–ª–∏ —ç–∫–æ–ª–æ–≥–∏—á–Ω–æ–≥–æ —Ç–æ–ø–ª–∏–≤–∞ –¥–æ 100%\n"
            "‚Ä¢ –®–∏–Ω—ã: –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–æ—Å—Ç–∞–≤—ã –¥–ª—è —Å–ø—Ä–∏–Ω—Ç-–≥–æ–Ω–æ–∫\n"
            "‚Ä¢ –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å: –£—Å–∏–ª–µ–Ω–Ω–∞—è –∑–∞—â–∏—Ç–∞ –∫–æ–∫–ø–∏—Ç–∞ –∏ –±–æ–∫–æ–≤—ã—Ö –ø–æ–Ω—Ç–æ–Ω–æ–≤\n"
            "‚Ä¢ –í–µ—Å: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –≤–µ—Å –±–æ–ª–∏–¥–∞ —Å–Ω–∏–∂–µ–Ω –¥–æ 795 –∫–≥") if language == "ru" else \
        ("üìè Formula 1 Technical Regulations 2025:\n\n"
         "‚Ä¢ Budget cap: $135 million per season\n"
         "‚Ä¢ Aerodynamics: New wind tunnel testing restrictions\n"
         "‚Ä¢ Engines: Increased sustainable fuel ratio to 100%\n"
         "‚Ä¢ Tires: Special compounds for sprint races\n"
         "‚Ä¢ Safety: Enhanced cockpit and sidepod protection\n"
         "‚Ä¢ Weight: Minimum car weight reduced to 795 kg")

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(
            text="üìã –ü–æ–ª–Ω—ã–π —Ä–µ–≥–ª–∞–º–µ–Ω—Ç" if language == "ru" else "üìã Full Regulations",
            url="https://www.fia.com/regulation/category/110"
        )],
        [InlineKeyboardButton(
            text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back",
            callback_data="paddock"
        )]
    ])

    image_path = find_image("f1_regulations.jpg")
    if image_path:
        photo = FSInputFile(image_path)
        await callback.message.delete()
        await bot.send_photo(
            chat_id=callback.message.chat.id,
            photo=photo,
            caption=text,
            reply_markup=keyboard
        )
    else:
        await callback.message.edit_text(text, reply_markup=keyboard)



drivers_info = {
    "Max Verstappen": {
        "birthdate": date(1997, 9, 30),
        "nationality": {"ru": "–ù–∏–¥–µ—Ä–ª–∞–Ω–¥—ã", "en": "Netherlands"},
        "team": "Red Bull Racing",
        "number": 1
    },
    "Liam Lawson": {
        "birthdate": date(2002, 2, 11),
        "nationality": {"ru": "–ù–æ–≤–∞—è –ó–µ–ª–∞–Ω–¥–∏—è", "en": "New Zealand"},
        "team": "Red Bull Racing",
        "number": 30
    },
    "Lewis Hamilton": {
        "birthdate": date(1985, 1, 7),
        "nationality": {"ru": "–í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏—è", "en": "United Kingdom"},
        "team": "Ferrari",
        "number": 44
    },
    "Charles Leclerc": {
        "birthdate": date(1997, 10, 16),
        "nationality": {"ru": "–ú–æ–Ω–∞–∫–æ", "en": "Monaco"},
        "team": "Ferrari",
        "number": 16
    },
    "George Russell": {
        "birthdate": date(1998, 2, 15),
        "nationality": {"ru": "–í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏—è", "en": "United Kingdom"},
        "team": "Mercedes",
        "number": 63
    },
    "Andrea Kimi Antonelli": {
        "birthdate": date(2006, 8, 25),
        "nationality": {"ru": "–ò—Ç–∞–ª–∏—è", "en": "Italy"},
        "team": "Mercedes",
        "number": 12
    },
    "Lando Norris": {
        "birthdate": date(1999, 11, 13),
        "nationality": {"ru": "–í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏—è", "en": "United Kingdom"},
        "team": "McLaren",
        "number": 4
    },
    "Oscar Piastri": {
        "birthdate": date(2001, 4, 6),
        "nationality": {"ru": "–ê–≤—Å—Ç—Ä–∞–ª–∏—è", "en": "Australia"},
        "team": "McLaren",
        "number": 81
    },
    "Lance Stroll": {
        "birthdate": date(1998, 10, 29),
        "nationality": {"ru":"–ö–∞–Ω–∞–¥–∞","en":"Canada"},
        "team": "Aston Martin",
        "number": 18
    },
    'Fernando Alonso': {
        'birthdate': date(1981, 7, 29),
        'nationality': {'ru': '–ò—Å–ø–∞–Ω–∏—è', 'en': 'Spain'},
        "team": "Aston Martin",
        "number": 14
    },
    'Alex Albon': {
        'birthdate': date(1996, 3, 23),
        'nationality': {'ru': '–¢–∞–∏–ª–∞–Ω–¥', 'en': 'Thailand'},

        "team": "Williams",
        "number": 23
    },
    'Carlos Sainz Jr.': {
        'birthdate': date(1994, 9, 1),
        'nationality': {'ru': '–ò—Å–ø–∞–Ω–∏—è', 'en': 'Spain'},
        "team": "Williams",
        "number": 55
    },
    'Nico H√ºlkenberg': {
        'birthdate': date(1987, 8, 18),
        'nationality': {'ru': '–ì–µ—Ä–º–∞–Ω–∏—è', 'en': 'Germany'},
        "team": "Kick Sauber",
        "number": 27
    },
    'Gabriel Bortoleto': {
        'birthdate': date(2004, 10, 14),
        'nationality': {'ru':'–ë—Ä–∞–∑–∏–ª–∏—è','en':'Brazil'},
        "team": "Kick Sauber",
        "number": 5
    },
    'Pierre Gasly': {
        'birthdate': date(1996, 2, 7),
        'nationality': {'ru':'–§—Ä–∞–Ω—Ü–∏—è','en':'France'},
        "team": "Alpine",
        "number": 10
    },
    'Jack Doohan': {
         'birthdate': date(2003, 1, 20),
         'nationality': {'ru':'–ê–≤—Å—Ç—Ä–∞–ª–∏—è','en':'Australia'},
        "team": "Alpine",
        "number": 7
    },
    'Yuki Tsunoda': {
         'birthdate': date(2000,5,11),
         'nationality': {'ru':'–Ø–ø–æ–Ω–∏—è','en':'Japan'},
        "team": "Racing Bulls",
        "number": 22
    },
    'Isack Hadjar': {
         'birthdate': date(2004,9,28),
         'nationality': {'ru':'–§—Ä–∞–Ω—Ü–∏—è','en':'France'},
        "team": "Racing Bulls",
        "number": 6
    },
    'Oliver Bearman': {
         'birthdate': date(2005,5,8),
         'nationality': {"ru": "–í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏—è", "en": "United Kingdom"},
        "team": "Haas",
        "number": 87
    },
    'Esteban Ocon': {
         'birthdate': date(1996,9,17),
         'nationality': {'ru':'–§—Ä–∞–Ω—Ü–∏—è','en':'France'},
        "team": "Haas",
        "number": 31
    }
}



def calculate_age(birthdate):
    today = date.today()
    age = today.year - birthdate.year - ((today.month, today.day) < (birthdate.month, birthdate.day))
    return age


team_logos = {
    "McLaren": "üü†",
    "Ferrari": "üî¥",
    "Red Bull Racing": "üîµ",
    "Mercedes": "‚ö™Ô∏è",
    "Aston Martin": "üíö",
    "Alpine": "üíô",
    "Haas": "‚ö™Ô∏è",
    "Racing Bulls": "üîµ",
    "Williams": "üîµ",
    "Kick Sauber": "üíö"
}


@router.callback_query(lambda c: c.data == "drivers")
async def show_drivers(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    # –°–ª–æ–≤–∞—Ä—å —Å URL –ª–æ–≥–æ—Ç–∏–ø–æ–≤ –∫–æ–º–∞–Ω–¥

    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–∏–ª–æ—Ç–æ–≤ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º
    team_drivers = {}
    for driver, data in drivers_info.items():
        team = data["team"]
        if team not in team_drivers:
            team_drivers[team] = []
        team_drivers[team].append(driver)


        team_buttons = []
        for team, drivers in team_drivers.items():
            if len(drivers) == 2:
                row = [
                    InlineKeyboardButton(
                        text=f"{team_logos[team]} {drivers[0]}",
                        callback_data=f"driver_{drivers[0]}"
                    ),
                    InlineKeyboardButton(
                        text=f"{team_logos[team]} {drivers[1]}",
                        callback_data=f"driver_{drivers[1]}"
                    )
                ]
                team_buttons.append(row)



    team_buttons = [
        # McLaren
        [
            InlineKeyboardButton(text=f"{team_logos['McLaren']} Lando Norris", callback_data="driver_Lando Norris"),
            InlineKeyboardButton(text=f"{team_logos['McLaren']} Oscar Piastri", callback_data="driver_Oscar Piastri")
        ],
        # Ferrari
        [
            InlineKeyboardButton(text=f"{team_logos['Ferrari']} Charles Leclerc",
                                 callback_data="driver_Charles Leclerc"),
            InlineKeyboardButton(text=f"{team_logos['Ferrari']} Lewis Hamilton", callback_data="driver_Lewis Hamilton")
        ],
        # Red Bull
        [
            InlineKeyboardButton(text=f"{team_logos['Red Bull Racing']} Max Verstappen",
                                 callback_data="driver_Max Verstappen"),
            InlineKeyboardButton(text=f"{team_logos['Red Bull Racing']} Liam Lawson", callback_data="driver_Liam Lawson")
        ],
        # Mercedes
        [
            InlineKeyboardButton(text=f"{team_logos['Mercedes']} George Russell",
                                 callback_data="driver_George Russell"),
            InlineKeyboardButton(text=f"{team_logos['Mercedes']} Andrea Kimi Antonelli",
                                 callback_data="driver_Andrea Kimi Antonelli")
        ],
        # Aston Martin
        [
            InlineKeyboardButton(text=f"{team_logos['Aston Martin']} Fernando Alonso",
                                 callback_data="driver_Fernando Alonso"),
            InlineKeyboardButton(text=f"{team_logos['Aston Martin']} Lance Stroll", callback_data="driver_Lance Stroll")
        ],
        # Alpine
        [
            InlineKeyboardButton(text=f"{team_logos['Alpine']} Pierre Gasly", callback_data="driver_Pierre Gasly"),
            InlineKeyboardButton(text=f"{team_logos['Alpine']} Jack Doohan", callback_data="driver_Jack Doohan")
        ],
        # Haas
        [
            InlineKeyboardButton(text=f"{team_logos['Haas']} Esteban Ocon", callback_data="driver_Esteban Ocon"),
            InlineKeyboardButton(text=f"{team_logos['Haas']} Oliver Bearman", callback_data="driver_Oliver Bearman")
        ],
        # Racing Bulls
        [
            InlineKeyboardButton(text=f"{team_logos['Racing Bulls']} Yuki Tsunoda",
                                 callback_data="driver_Yuki Tsunoda"),
            InlineKeyboardButton(text=f"{team_logos['Racing Bulls']} Isack Hadjar", callback_data="driver_Isack Hadjar")
        ],
        # Williams
        [
            InlineKeyboardButton(text=f"{team_logos['Williams']} Carlos Sainz Jr.",
                                 callback_data="driver_Carlos Sainz Jr."),
            InlineKeyboardButton(text=f"{team_logos['Williams']} Alex Albon", callback_data="driver_Alex Albon")
        ],
        # Sauber
        [
            InlineKeyboardButton(text=f"{team_logos['Kick Sauber']} Nico H√ºlkenberg",
                                 callback_data="driver_Nico H√ºlkenberg"),
            InlineKeyboardButton(text=f"{team_logos['Kick Sauber']} Gabriel Bortoleto",
                                 callback_data="driver_Gabriel Bortoleto")
        ],
        # –ö–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥"
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == 'ru' else "üîô Back", callback_data="paddock")]
    ]


    keyboard = InlineKeyboardMarkup(inline_keyboard=team_buttons)

    try:
        await callback.message.delete()
        await bot.send_photo(
            chat_id=callback.message.chat.id,
            photo="https://scontent-waw2-2.xx.fbcdn.net/v/t39.30808-6/470815360_874503911561169_9079399726029356248_n.jpg?_nc_cat=106&ccb=1-7&_nc_sid=127cfc&_nc_ohc=j5TRKOQvjfwQ7kNvgGdsmv2&_nc_zt=23&_nc_ht=scontent-waw2-2.xx&_nc_gid=AxZZBp-0VsyrFWup1asFFh4&oh=00_AYC41mrImpg--JH8eEXHAyBmdh4AZW7Lc41LUcIgr56YYw&oe=6775C750",
            reply_markup=keyboard
        )
    except Exception as e:
        print(f"Error in show_drivers: {e}")


@router.callback_query(lambda c: c.data.startswith("driver_"))
async def show_driver_info(callback: types.CallbackQuery):
    try:
        user_language = user_data[callback.from_user.id]["language"]
        driver_name = callback.data.split("_")[1]
        driver_data = drivers_info.get(driver_name)

        if not driver_data:
            await callback.answer(
                "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–∏–ª–æ—Ç–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞." if user_language == "ru" else "Driver information is unavailable."
            )
            return

        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        age = calculate_age(driver_data["birthdate"])
        nationality = driver_data["nationality"][user_language]
        team_name = driver_data["team"]
        driver_number = driver_data["number"]

        # –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –æ–¥–∏–Ω —Ä–∞–∑
        name_parts = driver_name.split()
        file_name = f"{name_parts[0][:3].lower()}{name_parts[-1][:3].lower()}.png"
        photo = FSInputFile(f"drivers_photo/{file_name}")

        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
        text = (
            f"üèéÔ∏è <b>{'–ò–º—è' if user_language == 'ru' else 'Name'}:</b> {driver_name}\n"
            f"üèÅ <b>{'–ö–æ–º–∞–Ω–¥–∞' if user_language == 'ru' else 'Team'}:</b> {team_name}\n"
            f"üî¢ <b>{'–ù–æ–º–µ—Ä' if user_language == 'ru' else 'Number'}:</b> {driver_number}\n"
            f"üéÇ <b>{'–í–æ–∑—Ä–∞—Å—Ç' if user_language == 'ru' else 'Age'}:</b> {age} {'–ª–µ—Ç' if user_language == 'ru' else 'years old'}\n"
            f"üåç <b>{'–ù–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å' if user_language == 'ru' else 'Nationality'}:</b> {nationality}"
        )

        # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(
                text="üîô –ù–∞–∑–∞–¥" if user_language == 'ru' else "üîô Back",
                callback_data="drivers"
            )]
        ])

        # –†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        await callback.message.edit_media(
            media=InputMediaPhoto(media=photo, caption=text, parse_mode='HTML'),
            reply_markup=keyboard
        )

    except Exception as e:
        print(f"Error in show_driver_info: {e}")
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞")




async def show_menu(callback: types.CallbackQuery, menu_type: str):
    language = user_data[callback.from_user.id]["language"]
    buttons = []

    if menu_type == "grand_prix":
        buttons = [
            [InlineKeyboardButton(text="üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ" if language == "ru" else "üìÖ Schedule", callback_data="schedule")],
            [InlineKeyboardButton(text="üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã" if language == "ru" else "üèÅ Results", callback_data="results")],
            [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="main_menu")]
        ]

    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    await callback.message.edit_text("–ú–µ–Ω—é –ì—Ä–∞–Ω-–ø—Ä–∏" if menu_type == "grand_prix" else "–ú–µ–Ω—é –ü–µ–ª–µ—Ç–æ–Ω",
                                     reply_markup=keyboard)



async def send_back_button(language):
    buttons = [
        [InlineKeyboardButton(text="üîô Back" if language == "en" else "üîô –ù–∞–∑–∞–¥", callback_data="main_menu")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


races = [
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ê–≤—Å—Ç—Ä–∞–ª–∏–∏", "en": "Australian Grand Prix"},
        "date": {"ru": "14-16 –º–∞—Ä—Ç–∞", "en": "March 14-16"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ê–≤—Å—Ç—Ä–∞–ª–∏–∏ üá¶üá∫</b>

üìÖ 14-16 –º–∞—Ä—Ç–∞ 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ê–ª—å–±–µ—Ä—Ç-–ü–∞—Ä–∫, –ú–µ–ª—å–±—É—Ä–Ω
üîÑ –ö—Ä—É–≥–æ–≤: 58
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 5,278 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 306,124 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ñ–∏–≤–æ–ø–∏—Å–Ω–∞—è –≥–æ—Ä–æ–¥—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞, –ø—Ä–æ–ª–æ–∂–µ–Ω–Ω–∞—è –≤–æ–∫—Ä—É–≥ –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –æ–∑–µ—Ä–∞ –≤ –ø–∞—Ä–∫–µ –ê–ª—å–±–µ—Ä—Ç.
–°–æ—á–µ—Ç–∞–µ—Ç –≤ —Å–µ–±–µ –±—ã—Å—Ç—Ä—ã–µ –ø–æ–≤–æ—Ä–æ—Ç—ã –∏ —Ç–µ—Ö–Ω–∏—á–Ω—ã–µ —Å–µ–∫—Ü–∏–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:19.813 - –®–∞—Ä–ª—å –õ–µ–∫–ª–µ—Ä (Ferrari, 2024)
""",
            "en": """
<b>‚Ä¢ Australian Grand Prix üá¶üá∫</b>

üìÖ March 14-16, 2025
üèéÔ∏è Circuit: Albert Park, Melbourne
üîÑ Laps: 58
üìè Lap length: 5.278 km
üèÅ Total distance: 306.124 km

üó∫Ô∏è Circuit description:
A picturesque street circuit laid out around an artificial lake in Albert Park. 
It combines fast corners with technical sections.

üèÜ Lap record:
1:19.813 - Charles Leclerc (Ferrari, 2024)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Australia_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ö–∏—Ç–∞—è", "en": "Chinese Grand Prix"},
        "date": {"ru": "21-23 –º–∞—Ä—Ç–∞", "en": "March 21-23"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ö–∏—Ç–∞—è üá®üá≥</b>

üìÖ 21-23 –º–∞—Ä—Ç–∞ 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–π –∞–≤—Ç–æ–¥—Ä–æ–º –®–∞–Ω—Ö–∞—è
üîÑ –ö—Ä—É–≥–æ–≤: 56
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 5,451 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 305,066 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ —Å —É–Ω–∏–∫–∞–ª—å–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π, –≤–∫–ª—é—á–∞—é—â–µ–π –¥–ª–∏–Ω–Ω—É—é –∑–∞–¥–Ω—é—é –ø—Ä—è–º—É—é –∏ —Å–ª–æ–∂–Ω—ã–µ –ø–æ–≤–æ—Ä–æ—Ç—ã.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:32.238 - –ú–∏—Ö–∞—ç–ª—å –®—É–º–∞—Ö–µ—Ä (Ferrari, 2004)
""",
            "en": """
<b>‚Ä¢ Chinese Grand Prix üá®üá≥</b>

üìÖ March 21-23, 2025
üèéÔ∏è Circuit: Shanghai International Circuit
üîÑ Laps: 56
üìè Lap length: 5.451 km
üèÅ Total distance: 305.066 km

üó∫Ô∏è Circuit description:
A modern track with a unique layout, featuring a long back straight and challenging corners.

üèÜ Lap record:
1:32.238 - Michael Schumacher (Ferrari, 2004)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/China_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –Ø–ø–æ–Ω–∏–∏", "en": "Japanese Grand Prix"},
        "date": {"ru": "4-6 –∞–ø—Ä–µ–ª—è", "en": "April 4-6"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –Ø–ø–æ–Ω–∏–∏ üáØüáµ</b>

üìÖ 4-6 –∞–ø—Ä–µ–ª—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –°—É–¥–∑—É–∫–∞
üîÑ –ö—Ä—É–≥–æ–≤: 53
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 5,807 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 307,471 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ –≤ —Ñ–æ—Ä–º–µ –≤–æ—Å—å–º–µ—Ä–∫–∏ —Å —Ç–µ—Ö–Ω–∏—á–Ω—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏ –∏ –∑–Ω–∞–º–µ–Ω–∏—Ç—ã–º S-–æ–±—Ä–∞–∑–Ω—ã–º —É—á–∞—Å—Ç–∫–æ–º.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:30.983 - –õ—å—é–∏—Å –•—ç–º–∏–ª—Ç–æ–Ω (Mercedes, 2019)
""",
            "en": """
<b>‚Ä¢ Japanese Grand Prix üáØüáµ</b>

üìÖ April 4-6, 2025
üèéÔ∏è Circuit: Suzuka
üîÑ Laps: 53
üìè Lap length: 5.807 km
üèÅ Total distance: 307.471 km

üó∫Ô∏è Circuit description:
A legendary figure-8 track with technical corners and the famous S-curves section.

üèÜ Lap record:
1:30.983 - Lewis Hamilton (Mercedes, 2019)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Japan_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ë–∞—Ö—Ä–µ–π–Ω–∞", "en": "Bahrain Grand Prix"},
        "date": {"ru": "11-13 –∞–ø—Ä–µ–ª—è", "en": "April 11-13"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ë–∞—Ö—Ä–µ–π–Ω–∞ üáßüá≠</b>

üìÖ 11-13 –∞–ø—Ä–µ–ª—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–π –∞–≤—Ç–æ–¥—Ä–æ–º –ë–∞—Ö—Ä–µ–π–Ω–∞
üîÑ –ö—Ä—É–≥–æ–≤: 57
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 5,412 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 308,238 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ –≤ –ø—É—Å—Ç—ã–Ω–µ —Å –¥–ª–∏–Ω–Ω—ã–º–∏ –ø—Ä—è–º—ã–º–∏ –∏ —Ç–µ—Ö–Ω–∏—á–Ω—ã–º–∏ —Å–µ–∫—Ü–∏—è–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:31.447 - –ü–µ–¥—Ä–æ –¥–µ –ª–∞ –†–æ—Å–∞ (McLaren, 2005)
""",
            "en": """
<b>‚Ä¢ Bahrain Grand Prix üáßüá≠</b>

üìÖ April 11-13, 2025
üèéÔ∏è Circuit: Bahrain International Circuit
üîÑ Laps: 57
üìè Lap length: 5.412 km
üèÅ Total distance: 308.238 km

üó∫Ô∏è Circuit description:
A modern desert track with long straights and technical sections.

üèÜ Lap record:
1:31.447 - Pedro de la Rosa (McLaren, 2005)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Bahrain_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –°–∞—É–¥–æ–≤—Å–∫–æ–π –ê—Ä–∞–≤–∏–∏", "en": "Saudi Arabian Grand Prix"},
        "date": {"ru": "18-20 –∞–ø—Ä–µ–ª—è", "en": "April 18-20"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –°–∞—É–¥–æ–≤—Å–∫–æ–π –ê—Ä–∞–≤–∏–∏ üá∏üá¶</b>

üìÖ 18-20 –∞–ø—Ä–µ–ª—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –î–∂–∏–¥–¥–∞ –ö–æ—Ä–Ω–∏—à –¢—Ä–µ–∫
üîÑ –ö—Ä—É–≥–æ–≤: 50
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 6,174 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 308,450 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–°–∫–æ—Ä–æ—Å—Ç–Ω–∞—è –≥–æ—Ä–æ–¥—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –¥–ª–∏–Ω–Ω—ã–º–∏ –ø—Ä—è–º—ã–º–∏ –∏ –±—ã—Å—Ç—Ä—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:30.734 - –õ—å—é–∏—Å –•—ç–º–∏–ª—Ç–æ–Ω (Mercedes, 2021)
""",
            "en": """
<b>‚Ä¢ Saudi Arabian Grand Prix üá∏üá¶</b>

üìÖ April 18-20, 2025
üèéÔ∏è Circuit: Jeddah Corniche Circuit
üîÑ Laps: 50
üìè Lap length: 6.174 km
üèÅ Total distance: 308.450 km

üó∫Ô∏è Circuit description:
A high-speed street circuit with long straights and fast corners.

üèÜ Lap record:
1:30.734 - Lewis Hamilton (Mercedes, 2021)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Saudi_Arabia_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ú–∞–π–∞–º–∏", "en": "Miami Grand Prix"},
        "date": {"ru": "2-4 –º–∞—è", "en": "May 2-4"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ú–∞–π–∞–º–∏ üá∫üá∏</b>

üìÖ 2-4 –º–∞—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–π –∞–≤—Ç–æ–¥—Ä–æ–º –ú–∞–π–∞–º–∏
üîÑ –ö—Ä—É–≥–æ–≤: 57
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 5,412 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 308,326 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ì–æ—Ä–æ–¥—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞ –≤–æ–∫—Ä—É–≥ —Å—Ç–∞–¥–∏–æ–Ω–∞ Hard Rock —Å –¥–ª–∏–Ω–Ω—ã–º–∏ –ø—Ä—è–º—ã–º–∏ –∏ —Ç–µ—Ö–Ω–∏—á–Ω—ã–º–∏ —Å–µ–∫—Ü–∏—è–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:29.708 - –ú–∞–∫—Å –§–µ—Ä—Å—Ç–∞–ø–ø–µ–Ω (Red Bull, 2023)
""",
            "en": """
<b>‚Ä¢ Miami Grand Prix üá∫üá∏</b>

üìÖ May 2-4, 2025
üèéÔ∏è Circuit: Miami International Autodrome
üîÑ Laps: 57
üìè Lap length: 5.412 km
üèÅ Total distance: 308.326 km

üó∫Ô∏è Circuit description:
A street circuit around the Hard Rock Stadium with long straights and technical sections.

üèÜ Lap record:
1:29.708 - Max Verstappen (Red Bull, 2023)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Miami_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –≠–º–∏–ª–∏–∏-–†–æ–º–∞–Ω—å–∏", "en": "Emilia Romagna Grand Prix"},
        "date": {"ru": "16-18 –º–∞—è", "en": "May 16-18"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –≠–º–∏–ª–∏–∏-–†–æ–º–∞–Ω—å–∏ üáÆüáπ</b>

üìÖ 16-18 –º–∞—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ê–≤—Ç–æ–¥—Ä–æ–º –≠–Ω—Ü–æ –∏ –î–∏–Ω–æ –§–µ—Ä—Ä–∞—Ä–∏
üîÑ –ö—Ä—É–≥–æ–≤: 63
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 4,909 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 309,049 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞ —Å —Ç–µ—Ö–Ω–∏—á–Ω—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏ –∏ –ø–µ—Ä–µ–ø–∞–¥–∞–º–∏ –≤—ã—Å–æ—Ç.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:15.484 - –õ—å—é–∏—Å –•—ç–º–∏–ª—Ç–æ–Ω (Mercedes, 2020)
""",
            "en": """
<b>‚Ä¢ Emilia Romagna Grand Prix üáÆüáπ</b>

üìÖ May 16-18, 2025
üèéÔ∏è Circuit: Autodromo Enzo e Dino Ferrari
üîÑ Laps: 63
üìè Lap length: 4.909 km
üèÅ Total distance: 309.049 km

üó∫Ô∏è Circuit description:
A historic track with technical corners and elevation changes.

üèÜ Lap record:
1:15.484 - Lewis Hamilton (Mercedes, 2020)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Emilia_Romagna_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ú–æ–Ω–∞–∫–æ", "en": "Monaco Grand Prix"},
        "date": {"ru": "23-25 –º–∞—è", "en": "May 23-25"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ú–æ–Ω–∞–∫–æ üá≤üá®</b>

üìÖ 23-25 –º–∞—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –¢—Ä–∞—Å—Å–∞ –ú–æ–Ω–∞–∫–æ
üîÑ –ö—Ä—É–≥–æ–≤: 78
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 3,337 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 260,286 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–∞—è –≥–æ—Ä–æ–¥—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞ —Å —É–∑–∫–∏–º–∏ —É–ª–∏—Ü–∞–º–∏ –∏ —Å–ª–æ–∂–Ω—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1.10.166 - –õ—å—é–∏—Å –•—ç–º–∏–ª—Ç–æ–Ω (Mercedes, 2019)
""",
            "en": """
<b>‚Ä¢ Monaco Grand Prix üá≤üá®</b>

üìÖ May 23-25, 2025
üèéÔ∏è Circuit: Circuit de Monaco
üîÑ Laps: 78
üìè Lap length: 3.337 km
üèÅ Total distance: 260.286 km

üó∫Ô∏è Circuit description:
A legendary street circuit with narrow streets and challenging corners.

üèÜ Lap record:
1.10.166 - Lewis Hamilton (Mercedes, 2019)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Monaco_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ò—Å–ø–∞–Ω–∏–∏", "en": "Spanish Grand Prix"},
        "date": {"ru": "30 –º–∞—è - 1 –∏—é–Ω—è", "en": "May 30 - June 1"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ò—Å–ø–∞–Ω–∏–∏ üá™üá∏</b>

üìÖ 30 –º–∞—è - 1 –∏—é–Ω—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ë–∞—Ä—Å–µ–ª–æ–Ω–∞-–ö–∞—Ç–∞–ª—É–Ω—å—è
üîÑ –ö—Ä—É–≥–æ–≤: 66
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 4,657 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 307,236 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ —Å —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏ –∏ —Ç–µ—Ö–Ω–∏—á–Ω—ã–º–∏ —Å–µ–∫—Ü–∏—è–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:18.149 - –ú–∞–∫—Å –§–µ—Ä—Å—Ç–∞–ø–ø–µ–Ω (Red Bull, 2021)
""",
            "en": """
<b>‚Ä¢ Spanish Grand Prix üá™üá∏</b>

üìÖ May 30 - June 1, 2025
üèéÔ∏è Circuit: Circuit de Barcelona-Catalunya
üîÑ Laps: 66
üìè Lap length: 4.657 km
üèÅ Total distance: 307.236 km

üó∫Ô∏è Circuit description:
A modern track with a variety of corners and technical sections.

üèÜ Lap record:
1:18.149 - Max Verstappen (Red Bull, 2021)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Spain_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ö–∞–Ω–∞–¥—ã", "en": "Canadian Grand Prix"},
        "date": {"ru": "13-15 –∏—é–Ω—è", "en": "June 13-15"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ö–∞–Ω–∞–¥—ã üá®üá¶</b>

üìÖ 13-15 –∏—é–Ω—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ñ–∏–ª—å –í–∏–ª—å–Ω—ë–≤
üîÑ –ö—Ä—É–≥–æ–≤: 70
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 4,361 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 305,270 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ü–æ–ª—É–≥–æ—Ä–æ–¥—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞ –Ω–∞ –æ—Å—Ç—Ä–æ–≤–µ –ù–æ—Ç—Ä-–î–∞–º —Å –¥–ª–∏–Ω–Ω—ã–º–∏ –ø—Ä—è–º—ã–º–∏ –∏ —à–∏–∫–∞–Ω–∞–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:13.078 - –í–∞–ª—Ç—Ç–µ—Ä–∏ –ë–æ—Ç—Ç–∞—Å (Mercedes, 2019)
""",
            "en": """
<b>‚Ä¢ Canadian Grand Prix üá®üá¶</b>

üìÖ June 13-15, 2025
üèéÔ∏è Circuit: Circuit Gilles Villeneuve
üîÑ Laps: 70
üìè Lap length: 4.361 km
üèÅ Total distance: 305.270 km

üó∫Ô∏è Circuit description:
A semi-street circuit on Notre Dame Island with long straights and chicanes.

üèÜ Lap record:
1:13.078 - Valtteri Bottas (Mercedes, 2019)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Canada_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ê–≤—Å—Ç—Ä–∏–∏", "en": "Austrian Grand Prix"},
        "date": {"ru": "27-29 –∏—é–Ω—è", "en": "June 27-29"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ê–≤—Å—Ç—Ä–∏–∏ üá¶üáπ</b>

üìÖ 27-29 –∏—é–Ω—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –†–µ–¥ –ë—É–ª–ª –†–∏–Ω–≥
üîÑ –ö—Ä—É–≥–æ–≤: 71
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 4,318 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 306,452 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ö–æ—Ä–æ—Ç–∫–∞—è, –Ω–æ –¥–∏–Ω–∞–º–∏—á–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –ø–µ—Ä–µ–ø–∞–¥–∞–º–∏ –≤—ã—Å–æ—Ç –∏ –±—ã—Å—Ç—Ä—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:05.619 - –ö–∞—Ä–ª–æ—Å –°–∞–π–Ω—Å (Ferrari, 2020)
""",
            "en": """
<b>‚Ä¢ Austrian Grand Prix üá¶üáπ</b>

üìÖ June 27-29, 2025
üèéÔ∏è Circuit: Red Bull Ring
üîÑ Laps: 71
üìè Lap length: 4.318 km
üèÅ Total distance: 306.452 km

üó∫Ô∏è Circuit description:
A short but dynamic track with elevation changes and fast corners.

üèÜ Lap record:
1:05.619 - Carlos Sainz (Ferrari, 2020)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Austria_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏–∏", "en": "British Grand Prix"},
        "date": {"ru": "4-6 –∏—é–ª—è", "en": "July 4-6"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏–∏ üá¨üáß</b>

üìÖ 4-6 –∏—é–ª—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –°–∏–ª—å–≤–µ—Ä—Å—Ç–æ—É–Ω
üîÑ –ö—Ä—É–≥–æ–≤: 52
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 5,891 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 306,198 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –±—ã—Å—Ç—Ä—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏ –∏ –¥–ª–∏–Ω–Ω—ã–º–∏ –ø—Ä—è–º—ã–º–∏ —É—á–∞—Å—Ç–∫–∞–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1.24.303 - –õ—å—é–∏—Å –•—ç–º–∏–ª—å—Ç–æ–µ (Mercedes, 2020)
""",
            "en": """
<b>‚Ä¢ British Grand Prix üá¨üáß</b>

üìÖ July 4-6, 2025
üèéÔ∏è Circuit: Silverstone
üîÑ Laps: 52
üìè Lap length: 5.891 km
üèÅ Total distance: 306.198 km

üó∫Ô∏è Circuit description:
A historic track with fast corners and long straight sections.

üèÜ Lap record:
1.24.303 - Lewis Hamilton (Mercedes, 2020)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Great_Britain_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –í–µ–Ω–≥—Ä–∏–∏", "en": "Hungarian Grand Prix"},
        "date": {"ru": "1-3 –∞–≤–≥—É—Å—Ç–∞", "en": "August 1-3"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –í–µ–Ω–≥—Ä–∏–∏ üá≠üá∫</b>

üìÖ 1-3 –∞–≤–≥—É—Å—Ç–∞ 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –•—É–Ω–≥–∞—Ä–æ—Ä–∏–Ω–≥
üîÑ –ö—Ä—É–≥–æ–≤: 70
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 4,381 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 306,663 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ò–∑–≤–∏–ª–∏—Å—Ç–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º –º–µ–¥–ª–µ–Ω–Ω—ã—Ö –ø–æ–≤–æ—Ä–æ—Ç–æ–≤.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:13,447 - –õ—å—é–∏—Å –•—ç–º–∏–ª—Ç–æ–Ω (Mercedes, 2020)
""",
            "en": """
<b>‚Ä¢ Hungarian Grand Prix üá≠üá∫</b>

üìÖ August 1-3, 2025
üèéÔ∏è Circuit: Hungaroring
üîÑ Laps: 70
üìè Lap length: 4.381 km
üèÅ Total distance: 306.663 km

üó∫Ô∏è Circuit description:
A twisty track with many slow corners.

üèÜ Lap record:
1:16.627 - Lewis Hamilton (Mercedes, 2020)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Hungary_Circuit"
    },
{
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ë–µ–ª—å–≥–∏–∏", "en": "Belgian Grand Prix"},
        "date": {"ru": "25-27 –∏—é–ª—è", "en": "July 25-27"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ë–µ–ª—å–≥–∏–∏ üáßüá™</b>

üìÖ 25-27 –∏—é–ª—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –°–ø–∞-–§—Ä–∞–Ω–∫–æ—Ä—à–∞–º
üîÑ –ö—Ä—É–≥–æ–≤: 44
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 7,004 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 308,052 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –ø–µ—Ä–µ–ø–∞–¥–∞–º–∏ –≤—ã—Å–æ—Ç –∏ –∑–Ω–∞–º–µ–Ω–∏—Ç—ã–º –ø–æ–≤–æ—Ä–æ—Ç–æ–º Eau Rouge.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:41,252 - –õ—å—é–∏—Å –•—ç–º–∏–ª—å—Ç–æ–Ω (Mercedes, 2020)
""",
            "en": """
<b>‚Ä¢ Belgian Grand Prix üáßüá™</b>

üìÖ July 25-27, 2025
üèéÔ∏è Circuit: Circuit de Spa-Francorchamps
üîÑ Laps: 44
üìè Lap length: 7.004 km
üèÅ Total distance: 308.052 km

üó∫Ô∏è Circuit description:
A legendary track with elevation changes and the famous Eau Rouge corner.

üèÜ Lap record:
1:46.286 - Valtteri Bottas (Mercedes, 2018)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Belgium_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ù–∏–¥–µ—Ä–ª–∞–Ω–¥–æ–≤", "en": "Dutch Grand Prix"},
        "date": {"ru": "29-31 –∞–≤–≥—É—Å—Ç–∞", "en": "August 29-31"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ù–∏–¥–µ—Ä–ª–∞–Ω–¥–æ–≤ üá≥üá±</b>

üìÖ 29-31 –∞–≤–≥—É—Å—Ç–∞ 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ó–∞–Ω–¥–≤–æ—Ä—Ç
üîÑ –ö—Ä—É–≥–æ–≤: 72
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 4,259 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 306,587 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–¢–µ—Ö–Ω–∏—á–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –Ω–∞–∫–ª–æ–Ω–Ω—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:08,885 - –ú–∞–∫—Å –§–µ—Ä—Å—Ç–∞–ø–ø–µ–Ω (Red Bull, 2021)
""",
            "en": """
<b>‚Ä¢ Dutch Grand Prix üá≥üá±</b>

üìÖ August 29-31, 2025
üèéÔ∏è Circuit: Circuit Zandvoort
üîÑ Laps: 72
üìè Lap length: 4.259 km
üèÅ Total distance: 306.587 km

üó∫Ô∏è Circuit description:
A technical track with unique banked corners.

üèÜ Lap record:
1:08,885 - Max Verstappen (Red Bull, 2021)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Netherlands_Circuit"
    },
 {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ò—Ç–∞–ª–∏–∏", "en": "Italian Grand Prix"},
        "date": {"ru": "5-7 —Å–µ–Ω—Ç—è–±—Ä—è", "en": "September 5-7"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ò—Ç–∞–ª–∏–∏ üáÆüáπ</b>

üìÖ 5-7 —Å–µ–Ω—Ç—è–±—Ä—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ú–æ–Ω—Ü–∞
üîÑ –ö—Ä—É–≥–æ–≤: 53
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 5,793 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 306,720 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–°–∫–æ—Ä–æ—Å—Ç–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –¥–ª–∏–Ω–Ω—ã–º–∏ –ø—Ä—è–º—ã–º–∏ –∏ –∑–Ω–∞–º–µ–Ω–∏—Ç—ã–º–∏ —à–∏–∫–∞–Ω–∞–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:18,887 - –õ—å—é–∏—Å –•—ç–º–∏–ª—å—Ç–æ–Ω (Mercedes, 2020)
""",
            "en": """
<b>‚Ä¢ Italian Grand Prix üáÆüáπ</b>

üìÖ September 5-7, 2025
üèéÔ∏è Circuit: Monza
üîÑ Laps: 53
üìè Lap length: 5.793 km
üèÅ Total distance: 306.720 km

üó∫Ô∏è Circuit description:
A high-speed track with long straights and famous chicanes.

üèÜ Lap record:
1:18,887 - Lewis Hamilton (Mercedes, 2020)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Italy_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ê–∑–µ—Ä–±–∞–π–¥–∂–∞–Ω–∞", "en": "Azerbaijan Grand Prix"},
        "date": {"ru": "19-21 —Å–µ–Ω—Ç—è–±—Ä—è", "en": "September 19-21"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ê–∑–µ—Ä–±–∞–π–¥–∂–∞–Ω–∞ üá¶üáø</b>

üìÖ 19-21 —Å–µ–Ω—Ç—è–±—Ä—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ì–æ—Ä–æ–¥—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞ –ë–∞–∫—É
üîÑ –ö—Ä—É–≥–æ–≤: 51
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 6,003 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 306,049 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ì–æ—Ä–æ–¥—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞ —Å —Å–∞–º–æ–π –¥–ª–∏–Ω–Ω–æ–π –ø—Ä—è–º–æ–π –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ –∏ —É–∑–∫–∏–º —É—á–∞—Å—Ç–∫–æ–º –≤ —Å—Ç–∞—Ä–æ–º –≥–æ—Ä–æ–¥–µ.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:40,203 - –®–∞—Ä–ª—å –õ–µ–∫–ª–µ—Ä (Ferrari, 2023)
""",
            "en": """
<b>‚Ä¢ Azerbaijan Grand Prix üá¶üáø</b>

üìÖ September 19-21, 2025
üèéÔ∏è Circuit: Baku City Circuit
üîÑ Laps: 51
üìè Lap length: 6.003 km
üèÅ Total distance: 306.049 km

üó∫Ô∏è Circuit description:
A street circuit with the longest straight on the calendar and a narrow section in the old city.

üèÜ Lap record:
1:40,203 - Charles Leclerc (Ferrari, 2023)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Baku_Circuit"
    },
 {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –°–∏–Ω–≥–∞–ø—É—Ä–∞", "en": "Singapore Grand Prix"},
        "date": {"ru": "3-5 –æ–∫—Ç—è–±—Ä—è", "en": "October 3-5"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –°–∏–Ω–≥–∞–ø—É—Ä–∞ üá∏üá¨</b>

üìÖ 3-5 –æ–∫—Ç—è–±—Ä—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ú–∞—Ä–∏–Ω–∞-–ë—ç–π
üîÑ –ö—Ä—É–≥–æ–≤: 62
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 4,940 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 306,143 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ù–æ—á–Ω–∞—è –≥–æ—Ä–æ–¥—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–º –æ—Å–≤–µ—â–µ–Ω–∏–µ–º –∏ —Å–ª–æ–∂–Ω—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:29,525 - –õ–∞–Ω–¥–æ –ù–æ—Ä—Ä–∏—Å (McLaren, 2024)
""",
            "en": """
<b>‚Ä¢ Singapore Grand Prix üá∏üá¨</b>

üìÖ October 3-5, 2025
üèéÔ∏è Circuit: Marina Bay Street Circuit
üîÑ Laps: 62
üìè Lap length: 4.940 km
üèÅ Total distance: 306.143 km

üó∫Ô∏è Circuit description:
A night street circuit with artificial lighting and challenging corners.

üèÜ Lap record:
1:41.905 - Lewis Hamilton (Mercedes, 2018)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Singapore_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –°–®–ê", "en": "United States Grand Prix"},
        "date": {"ru": "17-19 –æ–∫—Ç—è–±—Ä—è", "en": "October 17-19"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –°–®–ê üá∫üá∏</b>

üìÖ 17-19 –æ–∫—Ç—è–±—Ä—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –¢—Ä–∞—Å—Å–∞ –ê–º–µ—Ä–∏–∫
üîÑ –ö—Ä—É–≥–æ–≤: 56
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 5,513 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 308,405 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –ø–µ—Ä–µ–ø–∞–¥–∞–º–∏ –≤—ã—Å–æ—Ç –∏ —Ç–µ—Ö–Ω–∏—á–Ω—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:32,029 - –í–∞–ª—Ç—Ç–µ—Ä–∏ –ë–æ—Ç—Ç–∞–º (Mercedes, 2019)
""",
            "en": """
<b>‚Ä¢ United States Grand Prix üá∫üá∏</b>

üìÖ October 17-19, 2025
üèéÔ∏è Circuit: Circuit of The Americas
üîÑ Laps: 56
üìè Lap length: 5.513 km
üèÅ Total distance: 308.405 km

üó∫Ô∏è Circuit description:
A modern track with elevation changes and technical corners.

üèÜ Lap record:
1:32,029 - Valtteri Bottas (Mercedes, 2019)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/USA_Circuit"
    },
 {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ú–µ–∫—Å–∏–∫–∏", "en": "Mexican Grand Prix"},
        "date": {"ru": "24-26 –æ–∫—Ç—è–±—Ä—è", "en": "October 24-26"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ú–µ–∫—Å–∏–∫–∏ üá≤üáΩ</b>

üìÖ 24-26 –æ–∫—Ç—è–±—Ä—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ê–≤—Ç–æ–¥—Ä–æ–º –∏–º–µ–Ω–∏ –±—Ä–∞—Ç—å–µ–≤ –†–æ–¥—Ä–∏–≥–µ—Å
üîÑ –ö—Ä—É–≥–æ–≤: 71
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 4,304 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 305,584 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–í—ã—Å–æ–∫–æ–≥–æ—Ä–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –¥–ª–∏–Ω–Ω–æ–π –ø—Ä—è–º–æ–π –∏ –∑–Ω–∞–º–µ–Ω–∏—Ç—ã–º —Å—Ç–∞–¥–∏–æ–Ω–Ω—ã–º –∫–æ–º–ø–ª–µ–∫—Å–æ–º.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:14,759 - –î–∞–Ω–∏—ç–ª—å –†–∏–∫–∫–∞—Ä–¥–æ (Red Bull, 2018)
""",
            "en": """
<b>‚Ä¢ Mexican Grand Prix üá≤üáΩ</b>

üìÖ October 24-26, 2025
üèéÔ∏è Circuit: Aut√≥dromo Hermanos Rodr√≠guez
üîÑ Laps: 71
üìè Lap length: 4.304 km
üèÅ Total distance: 305.584 km

üó∫Ô∏è Circuit description:
A high-altitude track with a long straight and famous stadium section.

üèÜ Lap record:
1:14,759 - Daniel Ricciardo (Red Bull, 2018)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Mexico_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ë—Ä–∞–∑–∏–ª–∏–∏", "en": "Brazilian Grand Prix"},
        "date": {"ru": "7-9 –Ω–æ—è–±—Ä—è", "en": "November 7-9"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ë—Ä–∞–∑–∏–ª–∏–∏ üáßüá∑</b>

üìÖ 7-9 –Ω–æ—è–±—Ä—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –ò–Ω—Ç–µ—Ä–ª–∞–≥–æ—Å
üîÑ –ö—Ä—É–≥–æ–≤: 71
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 4,309 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 305,879 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –ø–µ—Ä–µ–ø–∞–¥–∞–º–∏ –≤—ã—Å–æ—Ç –∏ —Ç–µ—Ö–Ω–∏—á–Ω—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:10.540 - –í–∞–ª—Ç—Ç–µ—Ä–∏ –ë–æ—Ç—Ç–∞—Å (Mercedes, 2018)
""",
            "en": """
<b>‚Ä¢ Brazilian Grand Prix üáßüá∑</b>

üìÖ November 7-9, 2025
üèéÔ∏è Circuit: Interlagos
üîÑ Laps: 71
üìè Lap length: 4.309 km
üèÅ Total distance: 305.879 km

üó∫Ô∏è Circuit description:
A classic track with elevation changes and technical corners.

üèÜ Lap record:
1:10.540 - Valtteri Bottas (Mercedes, 2018)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Brazil_Circuit"
    },
 {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –õ–∞—Å-–í–µ–≥–∞—Å–∞", "en": "Las Vegas Grand Prix"},
        "date": {"ru": "20-22 –Ω–æ—è–±—Ä—è", "en": "November 20-22"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –õ–∞—Å-–í–µ–≥–∞—Å–∞ üá∫üá∏</b>

üìÖ 20-22 –Ω–æ—è–±—Ä—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –õ–∞—Å-–í–µ–≥–∞—Å –°—Ç—Ä–∏–ø –°–µ—Ä–∫–∏—Ç
üîÑ –ö—Ä—É–≥–æ–≤: 50
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 6,201 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 310,050 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–ù–æ—á–Ω–∞—è –≥–æ—Ä–æ–¥—Å–∫–∞—è —Ç—Ä–∞—Å—Å–∞, –ø—Ä–æ—Ö–æ–¥—è—â–∞—è –ø–æ –∑–Ω–∞–º–µ–Ω–∏—Ç–æ–º—É –°—Ç—Ä–∏–ø—É –õ–∞—Å-–í–µ–≥–∞—Å–∞.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:35.490 - –û—Å–∫–∞—Ä –ü–∏–∞—Å—Ç—Ä–∏ (McLaren, 2023)
""",
            "en": """
<b>‚Ä¢ Las Vegas Grand Prix üá∫üá∏</b>

üìÖ November 20-22, 2025
üèéÔ∏è Circuit: Las Vegas Strip Circuit
üîÑ Laps: 50
üìè Lap length: 6.201 km
üèÅ Total distance: 310.050 km

üó∫Ô∏è Circuit description:
A night street circuit running through the famous Las Vegas Strip.

üèÜ Lap record:
1:35.490 - Oscar Piastri (McLaren, 2023)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Las_Vegas_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ö–∞—Ç–∞—Ä–∞", "en": "Qatar Grand Prix"},
        "date": {"ru": "28-30 –Ω–æ—è–±—Ä—è", "en": "November 28-30"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ö–∞—Ç–∞—Ä–∞ üá∂üá¶</b>

üìÖ 28-30 –Ω–æ—è–±—Ä—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –õ—É—Å–∞–∏–ª
üîÑ –ö—Ä—É–≥–æ–≤: 57
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 5,419 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 308,883 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–æ—á–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ —Å –±—ã—Å—Ç—Ä—ã–º–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞–º–∏ –∏ –¥–ª–∏–Ω–Ω—ã–º–∏ –ø—Ä—è–º—ã–º–∏.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:24.319 - –ú–∞–∫—Å –§–µ—Ä—Å—Ç–∞–ø–ø–µ–Ω (Red Bull, 2023)
""",
            "en": """
<b>‚Ä¢ Qatar Grand Prix üá∂üá¶</b>

üìÖ November 28-30, 2025
üèéÔ∏è Circuit: Lusail International Circuit
üîÑ Laps: 57
üìè Lap length: 5.419 km
üèÅ Total distance: 308.883 km

üó∫Ô∏è Circuit description:
A modern night circuit with fast corners and long straights.

üèÜ Lap record:
1:24.319 - Max Verstappen (Red Bull, 2023)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Qatar_Circuit"
    },
    {
        "name": {"ru": "–ì—Ä–∞–Ω-–ø—Ä–∏ –ê–±—É-–î–∞–±–∏", "en": "Abu Dhabi Grand Prix"},
        "date": {"ru": "5-7 –¥–µ–∫–∞–±—Ä—è", "en": "December 5-7"},
        "info": {
            "ru": """
<b>‚Ä¢ –ì—Ä–∞–Ω-–ø—Ä–∏ –ê–±—É-–î–∞–±–∏ üá¶üá™</b>

üìÖ 5-7 –¥–µ–∫–∞–±—Ä—è 2025
üèéÔ∏è –¢—Ä–∞—Å—Å–∞: –Ø—Å –ú–∞—Ä–∏–Ω–∞
üîÑ –ö—Ä—É–≥–æ–≤: 58
üìè –î–ª–∏–Ω–∞ –∫—Ä—É–≥–∞: 5,281 –∫–º
üèÅ –û–±—â–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: 306,183 –∫–º

üó∫Ô∏è –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–∞—Å—Å—ã:
–°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ç—Ä–∞—Å—Å–∞ —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –æ—Ç–µ–ª–µ–º –∏ –ø–æ–¥–∑–µ–º–Ω—ã–º –ø–∏—Ç-–ª–µ–π–Ω–æ–º.

üèÜ –†–µ–∫–æ—Ä–¥ –∫—Ä—É–≥–∞:
1:26.103 - –ú–∞–∫—Å –§–µ—Ä—Å—Ç–∞–ø–ø–µ–Ω (Red Bull, 2021)
""",
            "en": """
<b>‚Ä¢ Abu Dhabi Grand Prix üá¶üá™</b>

üìÖ December 5-7, 2025
üèéÔ∏è Circuit: Yas Marina Circuit
üîÑ Laps: 58
üìè Lap length: 5.281 km
üèÅ Total distance: 306.183 km

üó∫Ô∏è Circuit description:
A modern circuit with a unique hotel and underground pit lane.

üèÜ Lap record:
1:26.103 - Max Verstappen (Red Bull, 2021)
"""
        },
        "image_url": "https://media.formula1.com/image/upload/f_auto,c_limit,q_auto,w_771/content/dam/fom-website/2018-redesign-assets/Circuit%20maps%2016x9/Abu_Dhabi_Circuit"
    }
]


@router.callback_query(lambda c: c.data == "schedule")
async def show_schedule(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    language = user_data[user_id]["language"]
    buttons = [
        [InlineKeyboardButton(text=f"{i + 1}. {race['name'][language]}", callback_data=f"track_{i}")]
        for i, race in enumerate(races)
    ]
    buttons.append([InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="grand_prix")])
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    text = "üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≥–æ–Ω–æ–∫ –Ω–∞ 2025 –≥–æ–¥:" if language == "ru" else "üìÖ 2025 Race Schedule:"

    try:
        # –ü–æ–ø—ã—Ç–∫–∞ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        await callback.message.edit_text(text, reply_markup=keyboard)
    except TelegramBadRequest as e:
        if "there is no text in the message to edit" in str(e).lower():
            # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–µ–∫—Å—Ç–∞, —É–¥–∞–ª—è–µ–º –µ–≥–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
            await callback.message.delete()
            await callback.message.answer(text, reply_markup=keyboard)
        elif "message is not modified" in str(e).lower():
            # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, –µ—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
            pass
        else:
            # –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞, –ø—Ä–æ–±—É–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            await callback.message.answer(text, reply_markup=keyboard)



@router.callback_query(lambda c: c.data.startswith("track_"))
async def show_track_info(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    track_id = int(callback.data.split("_")[1])
    track = races[track_id]

    text = (f"{track['info'][language]}")

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == 'ru' else 'üîô Back', callback_data='schedule')]
    ])

    await callback.message.delete()

    await bot.send_photo(
        chat_id=callback.message.chat.id,
        photo=track['image_url'],
        caption=text,
        parse_mode='HTML',
        reply_markup=keyboard
    )

async def get_pilots_list():
    return [
        "Max Verstappen",
        "Lando Norris",
        "Charles Leclerc",
        "Oscar Piastri",
        "Lewis Hamilton",
        "George Russell",
        "Fernando Alonso",
        "Lance Stroll",
        "Pierre Gasly",
        "Jack Doohan",
        "Esteban Ocon",
        "Oliver Bearman",
        "Gabriel Bortoleto",
        "Nico H√ºlkenberg",
        "Liam Lawson",
        "Isack Hadjar",
        "Franco Colapinto",
        "Carlos Sainz Jr.",
        "Andrea Kimi Antonelli"
    ]

async def get_teams_list():
    return [
        "Red Bull Racing",
        "Ferrari",
        "Mercedes",
        "McLaren",
        "Aston Martin",
        "Alpine",
        "Williams",
        "Racing Bulls",
        "Sauber",
        "Haas"
    ]


@router.callback_query(lambda c: c.data == "predictions")
async def show_predictions_menu(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    language = user_data[user_id]["language"]

    loading_text = "–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö..." if language == "ru" else "Loading data..."

    try:
        await callback.message.edit_text(loading_text)
    except TelegramBadRequest:
        await callback.message.delete()
        loading_message = await callback.message.answer(loading_text)
    else:
        loading_message = callback.message

    next_race = await get_next_race()

    if not next_race:
        # –ï—Å–ª–∏ –Ω–µ—Ç –ø—Ä–µ–¥—Å—Ç–æ—è—â–∏—Ö –≥–æ–Ω–æ–∫, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        text = "–ù–µ—Ç –ø—Ä–µ–¥—Å—Ç–æ—è—â–∏—Ö –≥–æ–Ω–æ–∫" if language == "ru" else "No upcoming races"
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="main_menu")]
        ])
        await loading_message.edit_text(text, reply_markup=keyboard)
        return

    buttons = [
        [InlineKeyboardButton(text=f"ü•á {pos}" if language == "ru" else f"ü•á {pos}", callback_data=f"predict_1_{pos}") for
         pos in range(1, 4)],
        [InlineKeyboardButton(text=f"ü•à {pos}" if language == "ru" else f"ü•à {pos}", callback_data=f"predict_2_{pos}") for
         pos in range(1, 4)],
        [InlineKeyboardButton(text=f"ü•â {pos}" if language == "ru" else f"ü•â {pos}", callback_data=f"predict_3_{pos}") for
         pos in range(1, 4)],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="main_menu")]
    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)

    text = f"üèÅ {'–ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞' if language == 'ru' else 'Prediction for'} {next_race['name']}\nüìÖ {next_race['date']}"

    await loading_message.edit_text(text, reply_markup=keyboard)


@router.callback_query(lambda c: c.data.startswith("predict_"))
async def handle_prediction(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    language = user_data[user_id]["language"]
    _, position, driver_number = callback.data.split("_")

    if "predictions" not in user_data[user_id]:
        user_data[user_id]["predictions"] = {}

    next_race = await get_next_race()
    user_data[user_id]["predictions"][next_race['name']] = user_data[user_id]["predictions"].get(next_race['name'], {})
    user_data[user_id]["predictions"][next_race['name']][position] = driver_number

    await save_user_data()
    await callback.answer("–ü—Ä–æ–≥–Ω–æ–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω" if language == "ru" else "Prediction saved")
    await show_predictions_menu(callback)

async def check_predictions(race_data):
    for user_id, data in user_data.items():
        if "predictions" in data and race_data['name'] in data["predictions"]:
            prediction = data["predictions"][race_data['name']]
            result = ""
            for pos, driver in prediction.items():
                actual = race_data['results'][int(pos) - 1]['DriverNumber']
                result += f"{pos}: {driver} {'‚úÖ' if driver == actual else ''}\n"

            language = data["language"]
            message = f"{'–í–∞—à –ø—Ä–æ–≥–Ω–æ–∑ –Ω–∞' if language == 'ru' else 'Your prediction for'} {race_data['name']}:\n{result}"
            await bot.send_message(user_id, message)

            del data["predictions"][race_data['name']]
            await save_user_data()



async def get_next_race():
    schedule = fastf1.get_event_schedule(2025)
    future_races = schedule[schedule['EventDate'] > datetime.now()]
    if future_races.empty:
        return None
    next_race = future_races.iloc[0]
    return {
        'name': next_race['EventName'],
        'date': next_race['EventDate'].strftime("%d.%m.%Y")
    }


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
@router.callback_query(lambda c: c.data == "settings")
async def show_settings(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    favorite_driver = user_data[callback.from_user.id].get("favorite_driver", "")
    favorite_team = user_data[callback.from_user.id].get("favorite_team", "")

    buttons = [
        [InlineKeyboardButton(text="üåê –Ø–∑—ã–∫ / Language", callback_data="change_language")],
        [InlineKeyboardButton(
            text=f"üë§ {'–õ—é–±–∏–º—ã–π –ø–∏–ª–æ—Ç:' if language == 'ru' else 'Favorite Driver:'} {favorite_driver} ‚úÖ" if favorite_driver else f"üë§ {'–õ—é–±–∏–º—ã–π –ø–∏–ª–æ—Ç' if language == 'ru' else 'Favorite Driver'}",
            callback_data="select_pilot")],
        [InlineKeyboardButton(
            text=f"üèé {'–õ—é–±–∏–º–∞—è –∫–æ–º–∞–Ω–¥–∞:' if language == 'ru' else 'Favorite Team:'} {favorite_team} ‚úÖ" if favorite_team else f"üèé {'–õ—é–±–∏–º–∞—è –∫–æ–º–∞–Ω–¥–∞' if language == 'ru' else 'Favorite Team'}",
            callback_data="select_team")],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="main_menu")]
    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    text = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏:" if language == "ru" else "Settings:"

    try:
        await callback.message.edit_text(text, reply_markup=keyboard)
    except TelegramBadRequest as e:
        if "there is no text in the message to edit" in str(e):
            # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–µ–∫—Å—Ç–∞, —É–¥–∞–ª—è–µ–º –µ–≥–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
            await callback.message.delete()
            await callback.message.answer(text, reply_markup=keyboard)
        else:
            # –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞, –ø—Ä–æ–±—É–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
            await callback.message.delete()
            await callback.message.answer(text, reply_markup=keyboard)


@router.callback_query(lambda c: c.data == "select_pilot")
async def select_favorite_pilot(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    pilots = await get_pilots_list()

    buttons = [
        [InlineKeyboardButton(
            text=f"{pilot} {'‚úÖ' if user_data[callback.from_user.id].get('favorite_driver') == pilot else ''}",
            callback_data=f"set_favorite_driver_{pilot}"
        )] for pilot in pilots
    ]

    # –ö–Ω–æ–ø–∫–∞ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –≤—ã–±–æ—Ä–∞
    buttons.append([InlineKeyboardButton(
        text="–û—á–∏—Å—Ç–∏—Ç—å –≤—ã–±–æ—Ä ‚ùå" if language == "ru" else "Clear selection ‚ùå",
        callback_data="clear_favorite_driver"
    )])

    buttons.append([InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="settings")])

    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    await callback.message.edit_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –ª—é–±–∏–º–æ–≥–æ –ø–∏–ª–æ—Ç–∞:" if language == "ru" else "Select your favorite driver:",
        reply_markup=keyboard
    )



@router.callback_query(lambda c: c.data.startswith("set_favorite_driver_"))
async def set_favorite_driver(callback: types.CallbackQuery):
    driver_name = callback.data.split("_")[3]
    user_id = callback.from_user.id
    user_data[user_id]["favorite_driver"] = driver_name
    await save_user_data()

    language = user_data[user_id]["language"]
    await callback.answer("‚úÖ –õ—é–±–∏–º—ã–π –ø–∏–ª–æ—Ç –≤—ã–±—Ä–∞–Ω!" if language == "ru" else "‚úÖ Favorite driver selected!")
    await show_settings(callback)



@router.callback_query(lambda c: c.data == "clear_favorite_driver")
async def clear_favorite_driver(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    user_data[user_id]["favorite_driver"] = None  # –û—á–∏—Å—Ç–∫–∞ –≤—ã–±–æ—Ä–∞
    await save_user_data()  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è

    language = user_data[user_id]["language"]
    await callback.answer(
        "‚úÖ –í—ã–±–æ—Ä –ª—é–±–∏–º–æ–≥–æ –ø–∏–ª–æ—Ç–∞ –æ—á–∏—â–µ–Ω!" if language == "ru" else "‚úÖ Favorite driver selection cleared!")

    await show_settings(callback)  # –í–æ–∑–≤—Ä–∞—Ç –∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º



@router.callback_query(lambda c: c.data == "select_team")
async def select_favorite_team(callback: types.CallbackQuery):
    language = user_data[callback.from_user.id]["language"]
    teams = await get_teams_list()

    buttons = [
        [InlineKeyboardButton(
            text=f"{team} {'‚úÖ' if user_data[callback.from_user.id].get('favorite_team') == team else ''}",
            callback_data=f"set_favorite_team_{team}"
        )] for team in teams
    ]

    # –ö–Ω–æ–ø–∫–∞ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –≤—ã–±–æ—Ä–∞
    buttons.append([InlineKeyboardButton(
        text="–û—á–∏—Å—Ç–∏—Ç—å –≤—ã–±–æ—Ä ‚ùå" if language == "ru" else "Clear selection ‚ùå",
        callback_data="clear_favorite_team"
    )])

    buttons.append([InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥" if language == "ru" else "üîô Back", callback_data="settings")])

    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    await callback.message.edit_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –ª—é–±–∏–º—É—é –∫–æ–º–∞–Ω–¥—É:" if language == "ru" else "Select your favorite team:",
        reply_markup=keyboard
    )



@router.callback_query(lambda c: c.data.startswith("set_favorite_team_"))
async def set_favorite_team(callback: types.CallbackQuery):
    team_name = "_".join(callback.data.split("_")[3:])
    user_id = callback.from_user.id
    user_data[user_id]["favorite_team"] = team_name
    await save_user_data()

    language = user_data[user_id]["language"]
    await callback.answer("‚úÖ –õ—é–±–∏–º–∞—è –∫–æ–º–∞–Ω–¥–∞ –≤—ã–±—Ä–∞–Ω–∞!" if language == "ru" else "‚úÖ Favorite team selected!")
    await show_settings(callback)



@router.callback_query(lambda c: c.data == "clear_favorite_team")
async def clear_favorite_team(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    user_data[user_id]["favorite_team"] = None  # –û—á–∏—Å—Ç–∫–∞ –≤—ã–±–æ—Ä–∞
    await save_user_data()  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è

    language = user_data[user_id]["language"]
    await callback.answer(
        "‚úÖ –í—ã–±–æ—Ä –ª—é–±–∏–º–æ–π –∫–æ–º–∞–Ω–¥—ã –æ—á–∏—â–µ–Ω!" if language == "ru" else "‚úÖ Favorite team selection cleared!")

    await show_settings(callback)  # –í–æ–∑–≤—Ä–∞—Ç –∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º



async def delete_message_after_delay(message, delay):
    await asyncio.sleep(delay)

    try:
        await message.delete()
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")



@router.callback_query(lambda c: c.data == 'change_language')
async def change_language(callback: types.CallbackQuery):
    buttons = [
        [InlineKeyboardButton(text="English", callback_data="set_lang_en")],
        [InlineKeyboardButton(text="–†—É—Å—Å–∫–∏–π", callback_data="set_lang_ru")],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥ / Back", callback_data="settings")]
    ]

    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)

    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ / Choose your language:", reply_markup=keyboard)


@router.callback_query(lambda c: c.data == 'main_menu')
async def go_back_to_main_menu(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    await callback.message.delete()
    await send_main_menu(callback.message.chat.id, user_data[user_id]["language"])



async def send_messages_in_batches(chat_id, messages):
    for message in messages:
        await bot.send_message(chat_id, message)
        await asyncio.sleep(0.1)


async def periodic_check():
    last_sent_race_data = load_last_race()
    while True:
        await delete_old_notifications()
        race_data = await get_race_results()
        if race_data and race_data["completed"]:
            if last_sent_race_data != {'name': race_data['name'], 'date': race_data['date']}:
                await send_favorite_notifications(race_data)
                await check_predictions(race_data)
                save_last_race({'name': race_data['name'], 'date': race_data['date']})
        await asyncio.sleep(40000)

async def main():
    global user_data  # –û–±—ä—è–≤–ª—è–µ–º user_data –∫–∞–∫ –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
    user_data.update(load_user_data())  # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

    bot_task = dp.start_polling(bot)  # –ó–∞–ø—É—Å–∫–∞–µ–º –æ–ø—Ä–æ—Å –±–æ—Ç–∞
    check_task = periodic_check()  # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫—É—é –ø—Ä–æ–≤–µ—Ä–∫—É
    await asyncio.gather(bot_task, check_task)  # –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞–¥–∞—á


if __name__ == "__main__":
    asyncio.run(main())
